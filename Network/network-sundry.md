### 1. http/1.0, http/1.1, http/2.0, http/3.0

- http/0.9: 1991年发布，及其简单，只有一个 get 命令;
- http/1.0: 1996年5月发布，增加了大量内容;
- http/1.1: 1997年1月发布，进一步完善 http 协议;
- SPDY: 2009年有 Google 发布，主要解决 http/1.1 效率不高的问题;
- http/2.0: 2015年借鉴SPDY的 http/2 发布;

客户端可以在TCP三次握手第三个报文段中捎带HTTP请求，节省资源。

影响一个http网络请求的因素主要有两个，就是带宽和延迟：
- 带宽：网络带宽指单位时间内传输的数据量，是数据的传输能力。随着网络基础建设较为完善，基本不用担心带宽影响网速。
- 延迟：
  1. 浏览器阻塞(head of line blocking ?): 浏览器对于同一个域名，同时只能有6个连接(根据浏览器内核可能有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞。这也是为何一些站点会有多个静态资源CDN域名的原因之一。
  2. DNS查询：解析域名为IP,一般使用DNS缓存来减少这个时间。
  3. 建立连接：http基于TCP,浏览器最开也要在第三次握手时才能携带HTTP请求报文，达到真正的连接建立。这些连接若无法复用则会导致每次请求都经历三次握手和慢启动，客户端和服务器也需要不停的分配和回收TCP缓存空间以及变量。三次握手在高延迟场景下影响比较明显，慢开始则对文件类大请求影响较大。

#### 1.1 http/1.0
http/1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都与服务器建立一个TCP连接,服务器完成请求处理后立即断开TCP连接。它的主要问题在于：
1. 一个网页中需要对图片，JS文件，CSS文件发出多个请求，而对每个请求，都需要建立新的连接。
2. 而TCP连接的建立和释放相对费时，且每次建立TCP连接之后都要执行慢开始算法。
3. TCP 连接建立时，客户机和服务器都需要为其分配缓存空间和变量并在连接释放时回收他们。当请求数量大时，这也会影响到客户机和服务器的性能。

http/1.0 中持续连接是关闭的，需要在http header 中加入：`connection: keep-alive; keep-alive: timeout = 5, max = 1000`类似的内容才能持续连接。而 http/1.1 中默认启用持续连接，加入 `connection: close` 才关闭。connection 在 request 和 response 的 header 中均可出现，只要其值为 `close`,则该连接会在请求处理完毕后释放调。http/1.0 中，虽然标准没有规定，但某些服务器对 ``connection: keep-alive` 的 Header 进行了支持。

http/1.1 之前的 http 版本的默认连接都是非持久连接。为此，若想在旧版本的 http 协议上维持持续连接，则需要指定 `Connection` 首部字段的置为 `keep-alive`。 —— 《图解HTTP》

#### 1.2 http/1.1
http/1.1 进一步完善了 http 协议，是目前最流行的版本。
它和 http/1.0 的**主要**区别在于：
1. 缓存处理： 引入了更多的缓存控制策略。
2. 错误状态处理：新增了24个错误状态相应码，如409, 410 等。
3. 范围请求：http/1.0 中，存在一些浪费带宽的现象，如若客户端只需某个对象的一部分，服务器却会将整个对象送过来，且不支持断点续传功能。http/1.1 在请求头引入了 range 头域，它允许值请求资源的某个部分(返回码是206),这样就方便了开发者自由的选择以便充分利用带宽和连接，支持断点续传。
4. Host头：http/1.0 中认为每台服务器都绑定一个唯一的IP地址，因此请求的URL中并没有传递主机名。但随着技术发展，在一台物理服务器上可以存在多个虚拟主机，且它们共享一个IP地址。http/1.1的request 和 response 都支持 host 字段，且若 request 中没有 host 字段会报错(400 bad request)。使用 host 字段，可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。
5. 持久连接：http/1.1 最大的变化是引入持久连接(http/1.0似乎也可以有，但不是规范)，默认开启 `connection: keep-alive`,即 tcp 连接默认不关闭，可以被多个请求复用。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。但规范的做法是客户端在最后一个请求时，发送 `Connection: close`,明确要求服务器关闭TCP连接。

6. 管道机制(pipelining): 在同一个TCP连接中，客户端可以同时发送多个请求(流水线方式)。但现代浏览器中并不默认启用 pipelining，因为它存在一些问题：
   - 一些代理浏览器不能正确处理 pipelining。
   - 正确的流水线实现复杂。
   - 流水线受制于 head-of-line-blocking 问题。不使用 pipelining 时，若一个请求响应处理了很久，则之后的请求可能直接走其他的TCP连接，可以一定程度上缓解这个问题。
   - 只有 idempotent 方式的 http 请求才能应用到 pipelining。idempotent 指的是同样的请求被执行一次与执行多次的效果是一样的，服务器的状态也是一样的：get, head, put, delete 方法都是 idempotent 的，而 post 方法不是。应该是因为，如果出现故障，则不知道 pipelining 中哪些请求已经被服务器执行了，所以需要 pipelining 中的请求都可以简单的重传。

![http/1.x-connection](/Image/http1.x-connection.png)

需要注意的是 http 的连接管理适用于两个连续节点之间的连接，如 hop-by-hop, 而不是 end-to-end。如 `Connection`和`Keep-Alive` 就是 `hop-by-hop` 协议头，它们的值是可以被中间结点修改的。

虽然 http/1.1 使用了持久连接和管道机制来复用TCP连接且同时发送多个请求，但所有的数据通信都是按次序完成的，服务器只有处理完一个响应，才会处理下一个响应。因此，有时候若某个请求的处理特别慢，则之后的请求都得排队等着，这成为"队头阻塞(head-of-line-blocking)"。虽然浏览器可以针对单个域名开启6个左右的连接并通过各个连接分别发送请求，能在一定程度上解决这个问题，但每个连接中依然会存在这个问题。

参考：
- [如何优雅的谈论HTTP/1.0，http/1.1，http/2.0](https://www.jianshu.com/p/52d86558ca57)
- [《图解HTTP》](https://kingyinliang.github.io/PDF/%E5%9B%BE%E8%A7%A3HTTP+%E5%BD%A9%E8%89%B2%E7%89%88.pdf)
- [http/1.0、http/1.1、http/2、https](https://zhuanlan.zhihu.com/p/43787334)
- [http/1.x 的连接管理-MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)
- [http/1.x 的缺点总结](https://segmentfault.com/a/1190000013519925)

#### 1.3 https(HyperText Transfer Protocol over SecureSocket Layer)
- SSL(secure socket lasyer, 安全套接层)/1.0: 1994年NetScape 公司设计，未发布；
- SSL/2.0: 1995年NetScape 公司发布，但存在严重漏洞；
- SSL/3.0: 1996年NetScape 公司发布，得到大规模应用；
- TLS(transport layer security, 安全层传输协议)/1.0: 1999年互联网标准化组织(ISOC)接替NetScape 公司，发布SSL的升级版TLS/1.0；
- TLS/1.1: 2006年发布；
- TLS/1.2: 2008年发布；
- TLS/1.2修订版:2011年发布；
SSL/TLS 协议位于TCP/IP协议与各种应用层协议之间，为数据通信提供安全支持。

HTTPS 可以说是安全版的 http, https 基于安全的SSL/TLS层，即在传统的HTTP和TCP之间加一层用于加密解密的SSL/TLS层。可以说HTTP加上加密处理、认证以及完整性保护后就是 HTTPS。 HTTP默认使用80端口，HTTPS默认使用443端口。

http 以及其他未加密的协议中都会出现的问题：
- 通信使用明文，内容可能会被窃听。
- 不验证通信方的身份，因此可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

SSL/TLS 协议是为了解决这三大风险而设计的，以期达到：
- 信息加密：第三方无法窃听。
- 校验机制：一旦被篡改，通信双方会立刻发现。
- 身份证书：防止身份被冒充。

##### 1.3.1 解决方案
SSL/TLS 的功能实现主要依赖于三类基本算法：散列函数、对称加密、非对称加密。利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据进行加密，基于散列函数验证信息的完整性。

1. 解决内容可能被窃听的问题 —— 加密

   对称加密：加密和解密用同一个密钥。使用对称加密时必须将密钥发送给对方，因此要确保密钥在转发途中的安全，另外还需要安全的保管收到的密钥。

   非对称加密：非对称加密使用一对非对称的密钥：公钥、私钥。私钥不能让其他任何人知道，公钥则可以随意发布，任何人都可以获得。

   非对称加密优点：
   - 使用非对称加密：发送方使用接收方的公钥进行加密，接收方收到信息后使用自己的私钥解密。这样不需发送用来解密的私钥，也不必担心密钥被攻击者窃听盗走。
   - 非对称加密可以一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。

   非对称加密缺点：
   - 公钥是公开的，所以针对私钥加密的信息，攻击者截获后可以使用公钥解密，获取其中的信息(理论上，公钥和私钥可以用任意一个加密，然后用另一个解密)。
   - 公钥中不包含服务器信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中就被中间人截获并篡改了。
   - 在数据加密解密过程中需要消耗一定时间，降低了传输效率。

   对称加密+非对称加密(https采用这样的方式)：
   使用对称加密的好处是解密的效率比较快，使用非对称加密的好处是传输的内容不能被破解。可以将二者结合起来，充分利用二者的优势，在交换密钥的阶段使用非对称加密的方式，之后的建立通信交换报文阶段则使用对称加密的方式。HTTPS 就采用这种对称加密和非对称加密并用的混合加密机制。

2. 解决报文可能遭篡改问题 —— 数字签名

   网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，需要通过校验数字签名来校验数据的完整性。

   数字签名有两种功效：
   - 能确定消息确实由发送方签名并发过来的。
   - 能确定消息的完整性，证明数据未被篡改过。

   数字签名的生成：将要发送的信息用 Hash 函数生成消息摘要，然后用发送方的私钥加密生成数字签名，与原信息一起传送给接收者。

   数字签名的校验：接收方使用发送方的公钥解密数字签名拿到摘要，再对收到的信息用Hash函数生成消息摘要，然后将两个摘要相对比。若相同，则说明收到的信息是完整的，在传输过程中没有被修改过。

   问题的关键在于，公钥如何安全的在网络中传送到客户端。此时就引入了证书颁发机构(Certificate Authority,简称CA),CA数量并不多，大多数操作系统CA证书是默认安装的。

3. 解决通信身份可能被伪装的问题 —— 数字证书
   数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

   使用数字证书认证的流程：
   1. 服务器的运营人员向CA提交公钥、组织信息、个人信息(域名)等信息并申请认证。
   2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性。
   3. 若信息审核通过，则 CA 会向申请者签发认证文件 —— 证书。证书包含：申请者公钥、申请者的组织和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文。证书中同时还包含一个数字签名：使用散列函数计算明文信息的摘要，然后使用CA的私钥对摘要进行加密，得到数字签名。
   4. 客户端向服务器发出请求时，服务器返回证书文件。
   5. 客户端读取证书中的明文信息，并使用散列函数计算得到其摘要。然后，使用对应CA的公钥解密签名数据，对比证书的信息摘要，若一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
   6. 客户端还会验证证书相关的域名信息、有效时间等信息。客户端内置了CA的证书信息(包含公钥)，若CA不被信任，则找不到对应的CA的证书，证书也会被判定非法。

4. https 工作流程
   1. SSL/TLS 四次握手(Client 和 Server 协商加密算法参数)：
      - Client 发送 Client Hello 消息，其中包含支持的SSL版本，支持的加密算法，随机数(client random)等信息。
      - Server 发送 Server Hello 消息，其中包含SSL版本，加密的算法，服务器证书，随机数(server random)等信息。
      - Client 验证证书：是否有效，是否对应请求站点，它的上一级证书是否有效(递归，直到验证到根证书)。若验证有效则发送消息：使用公钥加密的随机数(premaster secret),编码改变通知(表示随后的信息都将通过双方商定的加密方法和密钥发送)，Client 握手结束通知(同时也是前面发送的所有内容的 hash 值，用来供服务器校验。   加密？握手协商是否能够成功，以服务器能否正确解密该报文作为标准——《图解HTTP》)。
      - Server 收到加密的随机数后，使用私钥解密，获取到该随机数。向客户端发送信息：编码改变通知，Server 握手结束通知。
      - Client 和 Server 根据约定的算法，使用前面三个随机数生成对称密钥(session key)，用来加密接下来的整个对话过程。

   2. SSL 连接建立完成，通信受到SSL保护，从此处开始进行应用层协议的通信，也就是发送HTTP请求。

生成对话密钥需要三个随机数，但前两个随机数都有被窃听、篡改的可能，所以整个通话的安全，只取决于第三个随机数能否被破解。前两个随机数存在的原因是 SSL 协议不信任每个主机都能产生完全随机的随机数，若随机数不随机，则 pre master secret 就有可能被猜出来；而 Client 和 Server 的随机数加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能不够随机，但三个伪随机就十分接近随机了。

优点：
1. 数据传输的安全性(窃听无用)，数据完整，客户、服务器的身份认证。
2. 搜索引擎优先展示 https 结果。

缺点：
1. SSL 握手，加密、解密增加了延迟。
2. 加密、解密算法消耗 cpu 资源。
3. 证书申请需要额外的费用。

参考：
- [HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS](https://zhuanlan.zhihu.com/p/43787334)
- [深入理解HTTPS工作原理](https://juejin.im/post/5ca6a109e51d4544e27e3048#heading-1)
- 《图解HTTP》
- [https 运行原理解析笔记](https://coolcao.com/2018/08/06/https/)
- [SSL/TLS 协议运行机制的概述](https://juejin.im/entry/5b91e519e51d450e4627f605)

#### 1.4 http/2.0
http/2.0 是一种安全高效的下一代 http 传输协议，安全是因为 http/2.0 建立在 https 协议的基础上，高效是因为它通过二进制分帧来进行数据传输。

参考：
- [深入理解 http2.0 协议，看这篇就够了](https://juejin.im/entry/5dba82c3e51d452a17370818)