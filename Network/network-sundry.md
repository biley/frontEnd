### 1. http/1.0, http/1.1, http/2.0, http/3.0

- http/0.9: 1991年发布，及其简单，只有一个 get 命令;
- http/1.0: 1996年5月发布，增加了大量内容;
- http/1.1: 1997年1月发布，进一步完善 http 协议;
- SPDY: 2009年有 Google 发布，主要解决 http/1.1 效率不高的问题;
- http/2.0: 2015年借鉴SPDY的 http/2 发布;

客户端可以在TCP三次握手第三个报文段中捎带HTTP请求，节省资源。

影响一个http网络请求的因素主要有两个，就是带宽和延迟：
- 带宽：网络带宽指单位时间内传输的数据量，是数据的传输能力。随着网络基础建设较为完善，基本不用担心带宽影响网速。
- 延迟：
  1. 浏览器阻塞(head of line blocking ?): 浏览器对于同一个域名，同时只能有6个连接(根据浏览器内核可能有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞。这也是为何一些站点会有多个静态资源CDN域名的原因之一。
  2. DNS查询：解析域名为IP,一般使用DNS缓存来减少这个时间。
  3. 建立连接：http基于TCP,浏览器最开也要在第三次握手时才能携带HTTP请求报文，达到真正的连接建立。这些连接若无法复用则会导致每次请求都经历三次握手和慢启动，客户端和服务器也需要不停的分配和回收TCP缓存空间以及变量。三次握手在高延迟场景下影响比较明显，慢开始则对文件类大请求影响较大。

#### 1.1 http/1.0
http/1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都与服务器建立一个TCP连接,服务器完成请求处理后立即断开TCP连接。它的主要问题在于：
1. 一个网页中需要对图片，JS文件，CSS文件发出多个请求，而对每个请求，都需要建立新的连接。
2. 而TCP连接的建立和释放相对费时，且每次建立TCP连接之后都要执行慢开始算法。
3. TCP 连接建立时，客户机和服务器都需要为其分配缓存空间和变量并在连接释放时回收他们。当请求数量大时，这也会影响到客户机和服务器的性能。

http/1.0 中持续连接是关闭的，需要在http header 中加入：`connection: keep-alive; keep-alive: timeout = 5, max = 1000`类似的内容才能持续连接。而 http/1.1 中默认启用持续连接，加入 `connection: close` 才关闭。connection 在 request 和 response 的 header 中均可出现，只要其值为 `close`,则该连接会在请求处理完毕后释放调。http/1.0 中，虽然标准没有规定，但某些服务器对 ``connection: keep-alive` 的 Header 进行了支持。

http/1.1 之前的 http 版本的默认连接都是非持久连接。为此，若想在旧版本的 http 协议上维持持续连接，则需要指定 `Connection` 首部字段的置为 `keep-alive`。 —— 《图解HTTP》

#### 1.2 http/1.1
http/1.1 进一步完善了 http 协议，是目前最流行的版本。
它和 http/1.0 的**主要**区别在于：
1. 缓存处理： 引入了更多的缓存控制策略。
2. 错误状态处理：新增了24个错误状态相应码，如409, 410 等。
3. 范围请求：http/1.0 中，存在一些浪费带宽的现象，如若客户端只需某个对象的一部分，服务器却会将整个对象送过来，且不支持断点续传功能。http/1.1 在请求头引入了 range 头域，它允许值请求资源的某个部分(返回码是206),这样就方便了开发者自由的选择以便充分利用带宽和连接，支持断点续传。
4. Host头：http/1.0 中认为每台服务器都绑定一个唯一的IP地址，因此请求的URL中并没有传递主机名。但随着技术发展，在一台物理服务器上可以存在多个虚拟主机，且它们共享一个IP地址。http/1.1的request 和 response 都支持 host 字段，且若 request 中没有 host 字段会报错(400 bad request)。使用 host 字段，可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。
5. 持久连接：http/1.1 最大的变化是引入持久连接(http/1.0似乎也可以有，但不是规范)，默认开启 `connection: keep-alive`,即 tcp 连接默认不关闭，可以被多个请求复用。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。但规范的做法是客户端在最后一个请求时，发送 `Connection: close`,明确要求服务器关闭TCP连接。

6. 管道机制(pipelining): 在同一个TCP连接中，客户端可以同时发送多个请求(流水线方式)。但现代浏览器中并不默认启用 pipelining，因为它存在一些问题：
   - 一些代理浏览器不能正确处理 pipelining。
   - 正确的流水线实现复杂。
   - 流水线受制于 head-of-line-blocking 问题。不使用 pipelining 时，若一个请求响应处理了很久，则之后的请求可能直接走其他的TCP连接，可以一定程度上缓解这个问题。
   - 只有 idempotent 方式的 http 请求才能应用到 pipelining。idempotent 指的是同样的请求被执行一次与执行多次的效果是一样的，服务器的状态也是一样的：get, head, put, delete 方法都是 idempotent 的，而 post 方法不是。应该是因为，如果出现故障，则不知道 pipelining 中哪些请求已经被服务器执行了，所以需要 pipelining 中的请求都可以简单的重传。

![http/1.x-connection](/Image/http1.x-connection.png)

需要注意的是 http 的连接管理适用于两个连续节点之间的连接，如 hop-by-hop, 而不是 end-to-end。如 `Connection`和`Keep-Alive` 就是 `hop-by-hop` 协议头，它们的值是可以被中间结点修改的。

虽然 http/1.1 使用了持久连接和管道机制来复用TCP连接且同时发送多个请求，但所有的数据通信都是按次序完成的，服务器只有处理完一个响应，才会处理下一个响应。因此，有时候若某个请求的处理特别慢，则之后的请求都得排队等着，这成为"队头阻塞(head-of-line-blocking)"。虽然浏览器可以针对单个域名开启6个左右的连接并通过各个连接分别发送请求，能在一定程度上解决这个问题，但每个连接中依然会存在这个问题。

参考：
- [如何优雅的谈论HTTP/1.0，http/1.1，http/2.0](https://www.jianshu.com/p/52d86558ca57)
- [《图解HTTP》](https://kingyinliang.github.io/PDF/%E5%9B%BE%E8%A7%A3HTTP+%E5%BD%A9%E8%89%B2%E7%89%88.pdf)
- [http/1.0、http/1.1、http/2、https](https://zhuanlan.zhihu.com/p/43787334)
- [http/1.x 的连接管理-MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)
- [http/1.x 的缺点总结](https://segmentfault.com/a/1190000013519925)

#### 1.3 https(HyperText Transfer Protocol over SecureSocket Layer)
- SSL(secure socket lasyer, 安全套接层)/1.0: 1994年NetScape 公司设计，未发布；
- SSL/2.0: 1995年NetScape 公司发布，但存在严重漏洞；
- SSL/3.0: 1996年NetScape 公司发布，得到大规模应用；
- TLS(transport layer security, 安全层传输协议)/1.0: 1999年互联网标准化组织(ISOC)接替NetScape 公司，发布SSL的升级版TLS/1.0；
- TLS/1.1: 2006年发布；
- TLS/1.2: 2008年发布；
- TLS/1.2修订版:2011年发布；
SSL/TLS 协议位于TCP/IP协议与各种应用层协议之间(表示层)，为数据通信提供安全支持。

HTTPS 可以说是安全版的 http, https 基于安全的SSL/TLS层，即在传统的HTTP和TCP之间加一层用于加密解密的SSL/TLS层。可以说HTTP加上加密处理、认证以及完整性保护后就是 HTTPS。 HTTP默认使用80端口，HTTPS默认使用443端口。

http 以及其他未加密的协议中都会出现的问题：
- 通信使用明文，内容可能会被窃听。
- 不验证通信方的身份，因此可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

SSL/TLS 协议是为了解决这三大风险而设计的，以期达到：
- 信息加密：第三方无法窃听。
- 校验机制：一旦被篡改，通信双方会立刻发现。
- 身份证书：防止身份被冒充。

##### 1.3.1 解决方案
SSL/TLS 的功能实现主要依赖于三类基本算法：散列函数、对称加密、非对称加密。利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据进行加密，基于散列函数验证信息的完整性。

1. 解决内容可能被窃听的问题 —— 加密

   对称加密：加密和解密用同一个密钥。使用对称加密时必须将密钥发送给对方，因此要确保密钥在转发途中的安全，另外还需要安全的保管收到的密钥。

   非对称加密：非对称加密使用一对非对称的密钥：公钥、私钥。私钥不能让其他任何人知道，公钥则可以随意发布，任何人都可以获得。

   非对称加密优点：
   - 使用非对称加密：发送方使用接收方的公钥进行加密，接收方收到信息后使用自己的私钥解密。这样不需发送用来解密的私钥，也不必担心密钥被攻击者窃听盗走。
   - 非对称加密可以一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。

   非对称加密缺点：
   - 公钥是公开的，所以针对私钥加密的信息，攻击者截获后可以使用公钥解密，获取其中的信息(理论上，公钥和私钥可以用任意一个加密，然后用另一个解密)。
   - 公钥中不包含服务器信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中就被中间人截获并篡改了。
   - 在数据加密解密过程中需要消耗一定时间，降低了传输效率。

   对称加密+非对称加密(https采用这样的方式)：
   使用对称加密的好处是解密的效率比较快，使用非对称加密的好处是传输的内容不能被破解。可以将二者结合起来，充分利用二者的优势，在交换密钥的阶段使用非对称加密的方式，之后的建立通信交换报文阶段则使用对称加密的方式。HTTPS 就采用这种对称加密和非对称加密并用的混合加密机制。

2. 解决报文可能遭篡改问题 —— 数字签名

   网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，需要通过校验数字签名来校验数据的完整性。

   数字签名有两种功效：
   - 能确定消息确实由发送方签名并发过来的。
   - 能确定消息的完整性，证明数据未被篡改过。

   数字签名的生成：将要发送的信息用 Hash 函数生成消息摘要，然后用发送方的私钥加密生成数字签名，与原信息一起传送给接收者。

   数字签名的校验：接收方使用发送方的公钥解密数字签名拿到摘要，再对收到的信息用Hash函数生成消息摘要，然后将两个摘要相对比。若相同，则说明收到的信息是完整的，在传输过程中没有被修改过。

   问题的关键在于，公钥如何安全的在网络中传送到客户端。此时就引入了证书颁发机构(Certificate Authority,简称CA),CA数量并不多，大多数操作系统CA证书是默认安装的。

3. 解决通信身份可能被伪装的问题 —— 数字证书
   数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

   使用数字证书认证的流程：
   1. 服务器的运营人员向CA提交公钥、组织信息、个人信息(域名)等信息并申请认证。
   2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性。
   3. 若信息审核通过，则 CA 会向申请者签发认证文件 —— 证书。证书包含：申请者公钥、申请者的组织和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文。证书中同时还包含一个数字签名：使用散列函数计算明文信息的摘要，然后使用CA的私钥对摘要进行加密，得到数字签名。
   4. 客户端向服务器发出请求时，服务器返回证书文件。
   5. 客户端读取证书中的明文信息，并使用散列函数计算得到其摘要。然后，使用对应CA的公钥解密签名数据，对比证书的信息摘要，若一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
   6. 客户端还会验证证书相关的域名信息、有效时间等信息。客户端内置了CA的证书信息(包含公钥)，若CA不被信任，则找不到对应的CA的证书，证书也会被判定非法。

4. https 工作流程
   1. SSL/TLS 四次握手(Client 和 Server 协商加密算法参数)，在TCP建立连接之后进行：
      - Client 发送 Client Hello 消息，其中包含支持的SSL版本，支持的加密算法，随机数(client random)等信息。
      - Server 发送 Server Hello 消息，其中包含SSL版本，加密的算法，服务器证书，随机数(server random)等信息。
      - Client 验证证书：是否有效，是否对应请求站点，它的上一级证书是否有效(递归，直到验证到根证书)。若验证有效则发送消息：使用公钥加密的随机数(premaster secret),编码改变通知(表示随后的信息都将通过双方商定的加密方法和密钥发送)，Client 握手结束通知(同时也是前面发送的所有内容的 hash 值，用来供服务器校验。   加密？握手协商是否能够成功，以服务器能否正确解密该报文作为标准——《图解HTTP》)。
      - Server 收到加密的随机数后，使用私钥解密，获取到该随机数。向客户端发送信息：编码改变通知，Server 握手结束通知。
      - Client 和 Server 根据约定的算法，使用前面三个随机数生成对称密钥(session key)，用来加密接下来的整个对话过程。

   2. SSL 连接建立完成，通信受到SSL保护，从此处开始进行应用层协议的通信，也就是发送HTTP请求。

生成对话密钥需要三个随机数，但前两个随机数都有被窃听、篡改的可能，所以整个通话的安全，只取决于第三个随机数能否被破解。前两个随机数存在的原因是 SSL 协议不信任每个主机都能产生完全随机的随机数，若随机数不随机，则 pre master secret 就有可能被猜出来；而 Client 和 Server 的随机数加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能不够随机，但三个伪随机就十分接近随机了。

优点：
1. 数据传输的安全性(窃听无用)，数据完整，客户、服务器的身份认证。
2. 搜索引擎优先展示 https 结果。

缺点：
1. SSL 握手，加密、解密增加了延迟。
2. 加密、解密算法消耗 cpu 资源。
3. 证书申请需要额外的费用。

参考：
- [HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS](https://zhuanlan.zhihu.com/p/43787334)
- [深入理解HTTPS工作原理](https://juejin.im/post/5ca6a109e51d4544e27e3048#heading-1)
- 《图解HTTP》
- [https 运行原理解析笔记](https://coolcao.com/2018/08/06/https/)
- [SSL/TLS 协议运行机制的概述](https://juejin.im/entry/5b91e519e51d450e4627f605)

#### 1.3 SPDY
SPDY(读作“SPeeDY”) 是 Google 开发的基于TCP 的会话层协议，用以最小化网络延迟、提升网络速度、优化用户的网络使用体验。它并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。它的功能包括数据流的多路复用、请求优先级、HTTP 报头压缩。

IETF 对SPDY 协议进行了标准化，与 2015年5月推出了类似SPDY协议的HTTP2.0协议标准(http/2)，Google 因此宣布放弃对SPDY协议的支持，转而支持 HTTP/2。

#### 1.4 http/2
http/2 是一种安全高效的下一代 http 传输协议，安全是因为 http/2 建立在 https 协议的基础上，高效是因为它通过二进制分帧来进行数据传输。http/2 的设计本身允许非加密的http协议，但多数主流浏览器都声明只实现通过TLS加密的 http/2 协议，这使得经TLS加密的 http/2 成为了事实上的强制标准。

http/2 可以让我们的应用更块、更简单、更稳定，它将很多之前在应用中针对 http/1.1 想出来的“歪招”一笔勾销，把解决那些问题的方案内置在了传输层中。此外，它还为进一步优化应用和提升性能提供了全新的机会。它的主要目标是：
1. 通过支持完整的请求与响应复用来减少延迟。
2. 通过有效压缩 http header 字段降低协议开销。
3. 增加对请求优先级和服务器推送的支持。

http/2 没有改动 http 的应用语义，http 方法、状态代码、URI 和 标头字段等核心概念一如往常。不过，http/2 修改了数据的格式(分帧)以及在客户端与服务器间传输的方式，这二者统领全局，并通过新的分帧层向应用隐藏了所有复杂性。因此，所有现有的应用都可以直接在新协议上运行。

#### 1.4.1 设计和技术目标
早期版本的 http 协议的设计初衷主要是实现简单，但这是以牺牲性能为代价的：
1. http/1.x 要使用多个连接才能实现并发和缩短延迟。
2. http/1.x 不会压缩请求和响应标头。
3. http/1.x 不支持有效的资源优先级，支持底层TCP连接的利用率底下等等。

随着网络应用的范围、复杂性以及重要性不断增加，这些限制对网络开发者和用户都造成了巨大负担，这正是 http/2 要致力于解决的：
1. http/2 支持在同一连接上进行多个并发交换，对同一连接上的请求和响应消息进行交错发送。
2. http/2 支持 header 字段压缩。
3. http/2 允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能。
4. http/2 更有利于网络，因为它可以使用更少的TCP连接。
5. http/2 还可以通过使用二进制消息分帧对消息进行更高效的处理。

#### 1.4.2 二进制分帧层
http/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 http 消息并在客户端和服务器之间进行传送。这里的“层”指的是位于TCP与HTTP之间一个经过优化的新编码机制：http 的语义不受影响，不同的是传输期间对它们的编码方式变了。http/1.x 以换行符作为纯文本的分隔符，而 http/2 将所有传输的信息分分割为更小的消息和帧，并采用二进制格式对它们编码。因此，客户端和服务器为了相互理解，都必须使用新的二进制编码机制。

#### 1.4.3 数据流、消息和帧：
新的二进制分帧机制改变了客户端与服务器之间交换数据的方式，首先明确三个概念：
- 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息(一对请求和响应？)。
- 消息：与逻辑请求或响应消息对应的完整的一系列帧。
- 帧：http/2 通信的最小单位。

这些概念的关系总结如下：
- 所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一条逻辑 HTTP 消息(如请求或响应),包含一个或多个帧。
- 帧是最小的通信单位，承载着特定类型的数据(如http　header, 消息负载等等)，来自不同数据流的帧可以交错发送，然后在根据每个帧头的数据流标识符重新组装。

简而言之，http/2 将 http 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 tcp 连接内复用。这是 http/2 协议所有其他功能和性能优化的基础。

在 http/1.x 中，要发起多个并行请求以提升性能，则必须使用多个TCP连接，该模型可以保证每个连接每次只交付一个响应(响应排队)，且这种模型也会出现队首阻塞。二进制分帧层则突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 http 消息分解为互不依赖的帧，然后交错发送，最后在另一端把他们重新组装起来。
![http2-请求和相应复用](/Image/http2-connection.png)

将http 消息分解为独立的帧，交错发送，然后在另一端重新组装是 http2 最重要的一项增强。事实上，这个机制可以带来巨大的性能提升,让我们可以：
- 并行交错地发送多个请求，请求之间互不影响。
- 并行加错地发送多个响应，响应之间互不影响。
- 使用一个连接发送多个请求和响应。
- 不必再为绕过 http/1.x 限制而做很多工作(如级联文件、image sprites 和域名分片)。
- 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。
- ...

#### 1.4.4 数据流优先级：
将http 消息分解为很多独立的帧之后，客户端和服务器交错发送和传输这些帧的顺序也会影响到性能。为了决定顺序，http/2 允许每个数据流都有一个关联的权重和依赖关系：
- 可以向每个数据流分配一个１至256之间的整数。
- 每个数据流与其他数据流之间可以存在显示依赖关系。

数据流依赖关系和权重的组合让客户端可以构建和传递“优先级树”，表明它倾向于如何就收响应。服务器可以根据此信息通过控制CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，带宽分配可以确保将高优先级响应以最优方式传输至客户端。

资源分配方式：
1. http2 中的数据流依赖关系通过将另一个数据流的唯一标识符作为父项引用进行声明，忽略的话则将依赖于“根数据流”。该依赖关系指出，应**尽可能**向父数据流分配资源，然后再向其依赖项分配资源。
2. 共享相同父项的数据流按其权重比例分配资源。

依赖关系和权重组合明确表达了资源优先级，这是一种用于提升浏览性能的关键功能，网络中拥有多种资源类型，它们的依赖关系和权重各不相同。且 http/2 还允许客户端随时更新这些优先级，进一步优化了浏览器性能。

需要注意的是：优先级并不是绝对的，只是尽可能，客户端无法强制服务器通过数据流优先级以特定顺序处理数据。否则可能存在高优先级资源受到阻止时，还阻止服务器处理优先级较低的资源的情况。

参考：
- [深入理解 http2.0 协议，看这篇就够了](https://juejin.im/entry/5dba82c3e51d452a17370818)
- [http/2 简介](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn)
