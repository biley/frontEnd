## VUE
Vue 是一套用于构建用户界面渐进式框架，被设计为可以自底向上逐层应用。

Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。

### 1. 介绍
在 Vue 中，一个组件本质上是一个拥有预定义选项的一个 vue 实例。

### 2. vue 实例
每个 vue 应用都是通过用 vue 函数创建一个新的 Vue 实例开始的。

vue 的设计收到 mvvm 的启发，在文档中经常使用 `vm(ViewModel)`表示 vue 实例。

所有 vue 组件都是 vue 实例，并且接受相同的选项对象（一些根实例特有的选项除外）。

**数据与方法**
当一个 vue 实例被创建时，会将 data 对象中所有的 property 加入到 vue 的响应式系统中：
- 当这些 property 值发生改变时，视图会产生响应，即更新为新的值。只有当实例创建时就已经存在的 property 才是响应式的，新添加的 property 没有这样的效果。
- 使用 `Object.freeze()` 会阻止修改现有的 property，意味着响应系统无法在追踪变化。

除了数据 property, vue 还暴露了一些有用的实例 property 与方法，它们使用前缀 `$` 与用户定义的 property 区分开来。

method 将被混入到 vue 实例中，可以直接通过 vm 实例访问这些方法，或者在指令表达式中使用个，方法中的 this 自动绑定为 vue 实例（不应该使用箭头函数来定义 method 函数，否则 this 可能不会按照期望指向 vue 实例）。

**生命周期**
每个 vue 实例在被创建时都要经过一系列的初始化过程，需要设置数据监听、编译模板、实例挂载到 DOM、数据变化等更新 DOM 等，在这个过程中同时也会运行一些生命周期钩子函数，给了用户在不同阶段添加自己的代码的机会。

created、mounted、updated 和 destroyed 生命周期，其中的 this 指向调用它的 vue 实例。

不要在选项 property 或回调上使用箭头函数，这很有可能会导致 this 丢失。

### 3. 模板语法
vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 vue 实例的数据。所有 vue 的模板都是合法的 html，所以能被遵循规范的浏览器和 HTML 解析器解析。

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。

### 3.1 插值
**文本**

最常见的是使用双大括号的文本插值 `{{}}`，该值会被替代为对应数据对象上 property 的值。只要数据对象上的值发生了改变，插值处的内容都会更新。

通过 `v-once` 指令可以一次性的插值，之后数据将不会再改变。

**原始 html**

`{{}}` 会将数据解释为普通文本，而非 html 代码。为了输出真正的 html，需要使用 `v-html` 指令。它会直接将所在的标签替换为对应的 property 值（会忽略解析 property 中的数据绑定）。

不能使用 `v-html` 来复合局部模板，因为 vue 不是基于字符串的模板引擎。也要注意为了避免 xss 攻击，不要使用用户提供的内容做 html 插值。

**attribute**

对于 html attribute, 需要使用 `v-bind` 指令。

对于布尔 attribute（它们只要存在就意味着值为 true）,`v-bind`的表现略有不同。当对应的 property 值为 null、undefined 或 false 时，布尔 atrribute 甚至不会被包含在渲染出来的 html 元素中。

**js 表达式**

对于所有的数据绑定，vue 都提供了完全的 js 表达式支持。但只能包含单个表达式，语句以及流程控制都不会生效。

**模板表达式**（模板之中含有 js 表达式）都被放在沙盒中，只能访问全局变量的一个白名单（比如 Math 和 Date），不应该在其中访问用户定义的全局变量。

#### 3.2 指令
指令是带有 `v-`前缀的特殊 attribute，值预期是单个 js 表达式（v-for 是例外情况）。

指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式的作用于 DOM。

**参数**

一些指令能够接受一个参数，在指令名称后以冒号表示。

`v-bind` 指令可以用于响应式的更新 attribute（将 attribute 与表达式的值绑定），`v-on` 用于监听 DOM 事件（参数中是事件名）。

**动态参数**

从 2.6.0 开始，可以用方括号括起来的 js 表达式作为一个指令的参数，表达式的值会作为最终的参数来使用。

动态参数的约束：
- 对值的约束：动态参数预期会求出一个字符串，异常情况下为 null，这个 null 值可以被显性地用于移除绑定。其余非字符串类型的值都会触发一个警告。
- 对参数表达式的语法约束：
  - 某些字符，比如空格和引号，放在 html attribute 名称中是无效的。解决办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。
  - 在 DOM 中使用模板时（直接在一个 html 中写模板），需要避免使用大写字符来命名键名，因为浏览器会将 attribute 名全部强制转为小写。

**修饰符**

修饰符是以 `.` 好指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

#### 3.3 缩写
`v-` 前缀作为一种视觉提示，用来识别模板中 vue 特定的 attribute。为现有标签添加动态行为时，`v-` 很有帮助。而在构建由 vue 管理所有模板的 SPA 时，`v-`前缀变得没有那么重要。所以对于频繁用到的指令 v-bind 和 v-on，提供了特定简写。

```html
<a v-bind:href="url">...</a>
<a :href="url">...</a>
<a :[key]="url">...</a>

<a v-on:click="doSomething">...</a>
<a @click="doSomething">...</a>
<a @[event]="doSomething">...</a>
```

### 4. 计算属性和侦听器
#### 4.1 计算属性
模板中放入太多的逻辑会让模板过重且难以维护，对于任何复杂逻辑，都应当使用计算属性。

可以将计算属性的逻辑函数写成对应的 getter 函数。

vue 会根据计算属性所依赖属性的变化而更新计算属性，计算属性的 getter 函数是没有副作用的，这使它更易于测试和理解。

**计算属性 vs 方法**

可以通过在表达式中调用组件中的方法来达到同样的效果，不同点在于计算属性是基于它们的响应式依赖进行缓存的。

计算属性只在响应式依赖发生变化时才会重新求值，所以只要依赖没有变化，那么多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。

相比之下，每次触发重新渲染时，调用方法总会再次执行函数。

**计算属性 vs 侦听属性**

侦听属性提供了一种更通用的方式来观察和响应 vue 实例上的数据变动。当有一些数据需要随着其它数据变动而变动时，容易滥用 `watch`，通常更好的做法是使用计算属性而不是命令式的 watch 回调。

**计算属性的 setter**

计算属性默认只有 getter，但需要时也可以提供一个 setter。

#### 4.2 侦听器
计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器， vue 通过 `watch` 提供了一个更通用的方法来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。

除了 watch 选项之外，还可以使用命令式的 `vm.$watch`api。

### 5. class 与 style 绑定
元素的 class 列表和内联样式都是 attribute，有需要时可以使用 v-bind 处理它们：通过表达式计算出字符串结果即可。但字符串拼接麻烦易错，故在将 v-bind 用于 class 和 style 是，vue 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。

#### 5.1 绑定 html class
**对象语法**

可以传给 `v-bind:class` 一个对象，来动态切换 class，它还可以与普通 class 属性共存。绑定的数据对象不必内联定义在模板中，这样做渲染的结果是一样的。也可以在这里绑定一个返回对象的计算属性，这是一个常用且强大的模式。

**数组语法**

可以传给 `v-bind:class` 一个数组，以应用一个 class 列表。数组中可以使用三元表达式，也可以使用对象语法。

**用在组件上**

在一个自定义组件上使用 class 时，这些 class 将被添加到该组件的根元素上面，原有的 class 不会被覆盖。在使用时和定义时都可以添加 class。

#### 5.2 绑定内联样式
**对象语法**

`v-bind:style` 的对象语法看着非常像 css，但其实是一个 JS 对象。css 属性名可以用驼峰式或短横线分隔来命名。直接绑定到一个样式对象通常更好，会让模板更清晰。同样，对象语法常常结合返回对象的计算属性使用。

**数组语法**

`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上。

**自动添加前缀**

当 `v-bind:style` 使用需要添加浏览器引擎前缀的 css 属性时（如 transform），vue 会自动侦测并添加相应的前缀。

**多重置**

从 2.3.0 起可以为 `style` 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，这样写只会渲染数组中最后一个被浏览器支持的值。

### 6. 条件渲染

#### 6.1 v-if

`v-if` 用于条件性地渲染一块内容，这块内容只有在指定的表达式返回 truthy 值的时候被渲染。还可以使用 `v-else` 添加一个 else 快。

`v-if` 和 `v-else` 特点：
- `v-if` 是一个指令，必须添加到一个元素上。如果想切换多个元素，可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的结果不会包含 template 元素。
- `v-else` 元素必须紧跟在 `v-if` 或 `v-else-if` 元素后，否则不会被识别。
- `v-else-if` 充当 `v-if` 的 else-if 块，可以连续使用。也必须紧跟在 `v-if` 或 `v-else-if` 之后。

**用 key 管理可复用的元素**

vue 会尽可能高效地渲染元素，通常会复用已有的元素而不是从头开始渲染。所以 if 块和 else 块之间的相同元素会复用，比如 input 输入框在切换后依然会保留之前输入的值。所以若两个元素完全独立，不需要复用，可以添加一个具有唯一值的 key 属性。

#### 6.2 v-if vs v-show

v-show 也是一个根据条件展示元素的选项，不同的是 v-show 的元素使用会被渲染并保留在 DOM 中，它只是简单地切换元素的 css display 属性。

比较：
- v-if 是真正的条件渲染，它会确保在切换过程中条件块内容的事件监听器和子组件适当地被销毁和重建。
- v-if 是惰性的，直到条件第一次变为真时，才会开始渲染条件块。
- v-show 则不管初始条件是什么，元素总是会被渲染，只是加单的基于 css 进行切换。

一般来说：
- v-if 有更高的切换开销。v-show 有更高的初始渲染开销。
- 若在运行时条件很少改变，使用 v-if 较好。若需要非常频繁地切换，使用 v-show 比较好。

#### 6.2 v-if 和 v-for

不推荐同时使用 v-if 和 v-for（用在同一个元素上）。当二者一起使用时， v-for 具有比 v-if 更高的优先级。

### 7. 列表渲染

v-for 指令可以基于一个数组来渲染一个列表。

#### 7.1 v-for 的使用

特点：
1. 它需要使用 `item in items ` 形式的特殊语法看，也支持一个可选的第二个参数，表示当前项的索引。也可以使用 of 替代 in，它更接近 js 迭代器的语法。
2. 遍历的是对象时，它可以提供三个参数 value、name 和 index。遍历对象时，会按照 Object.keys() 的结果遍历，在不同的 js 引擎下结果可能不一致。
3. 在 v-for 块中，可以访问所有父作用域的 property。
4. v-for 接受整数，它会把模板重复对应次数。
5. 与 v-if 相似，可以使用 `template` 来循环渲染一段包含多个元素的内容。
6. 过滤或排序，可以创建计算属性。计算属性不适用的情况，可以再循环中使用方法。

**维护状态**

v-for 默认不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素。这个模式只适用于不依赖子组件状态或临时 DOM 状态（如表单项输入）的列表渲染输出。

使用 `key` 之后，vue 能跟踪每个节点的身份，从而重用和重新排序现有元素。

建议尽可能通过 key 属性，除非遍历输出的 DOM 非常简单，或刻意依赖默认行为以获取性能上的提升。

**v-for 和 v-if**

不推荐在同一元素上使用 v-if 和 v-for。当他们处于同一节点时，v-for 的优先级更高，这意味着 v-if 将分别重复运行与每个 v-for 循环中。只想为部分项渲染节点时，这种优先级的机制十分有用。

**在组件上使用 v-for**

在自定义组件上，可以向任何普通元素上一样使用 v-for。2.2.0+ 的版本中，在组件上使用 v-for 必须添加 key。

为了把迭代的数据传递到组件中，需要使用 prop。也就是使用 v-bind 将 item，index 等绑定到组件的 props 中。

#### 7.2 数组更新检测
**变更方法**

vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些方法包括：push()、pop()、shift()、unshift()、splice()、sort() 和 reverse()。

**替换数组**

变更方法是会变更调用了这些方法的原始数组。相比直线，也有非变更方法（比如 filter, concat, slice），它们不会变更原始数组，总是返回一个新数组。使用非变更方法时，可以使用新数组替换就数组。

数组的替换不一定会导致 vue 丢弃现有 DOM 并重新渲染整个列表，事实上，vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所用用一个含有相同元素的数组替换原来的数组是非常高效的操作。

由于 JS  限制，Vue 不能检测数组和对象的变化。

### 8 事件处理

### 9 表单输入绑定

### 10 组件基础

组件是可复用的 vue 实例，可以在通过 `new Vue` 创建的 vue 根实例中，把该组件作为自定义元素来使用。

组件是可复用的 vue 实例，所以它们与 `new vue` 接收相同的选项，比如（data、computed、watch、methods 以及生命周期钩子等），仅有一些根实例特有的选项除外。

每用一次组件，就会创建一个新实例，所以每个组件都会维护独立的数据。所以 **data 必须是一个函数**，这样每个实例可以维护一份被返回对象的独立的拷贝，否则各个组件之间的数据会互相影响。

**组件的组织**

通常一个应用会以一棵嵌套的组件树的形式来组织，而为了能在模板中使用，各个组件都必须先注册以便 vue 能够识别。组件的注册有两种类型：全局注册和局部注册。

**通过 prop 向子组件传递数据**

prop 是可以再组件上注册的一些自定义 attribute，当一个值传递给 prop attribute的时候，它就变成了那个组件实例的一个 property。

还可以使用 `v-bind` 来动态传递 prop，这在一开始不清楚要渲染的具体内容（比如 v-for 循环的数据或从一个 api 获取的数据）是非常有用的。

**单个根元素**

每个组件必须只有一个根元素，所以一般会将模板的内容包裹在一个父元素内来解决这个问题，同样也可以将各个 prop 合并成一个对象。

**插槽**

vue 自定义的 `<slot>` 元素使得定义插槽相关的组件变得简单。

**动态组件**

有时，在不同组件之间进行动态切换非常有用，vue 提供了一个特殊的 `is` attribute 来实现这样的功能。

`is` attribute 可以用于常规 html 元素，这些元素会被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，如果想要让它如预期般工作，需要私用 `.prop` 修饰器。

**解析 DOM 模板时的注意事项**

有些 html 元素，如 `<ul>`、`<table>`、`<select>` 、`<ol>`，对于哪些元素可以出现在其内部有严格的限制。而有的，如 `<li>`、`<tr>`、`<option>`，只能出现在其他某些特定的元素内部。

这些限制会导致自定义组件被视为无效的内容提升到外部，并导致最终渲染结果出错。而 `ls` attribute 提供了一个变通的方法。

若从以下来源使用模板，这些限制是不存在的：
- 字符串
- 单文件组件
- `<script type="text/x-template">`

#### 10.1 子组件事件
**子组件事件**

vue 实例提供了自定义的系统，父级组件可以像处理 native DOM 事件一样通过 `v-on` 监听子组件实例的任意事件。同时子组件可以通过调用内建的 `$emit` 方法并传入事件名称来触发一个事件。

`$emit` 的第二个参数可以随事件一起传递出去。

**在组件上使用 v-model**

```html
<input v-model="text">

<!-- 等价于 -->

<input
  v-bind:value="text"
  v-on:input="text=$event.target.value"
>
```
所以，要在一个组件上使用 v-model，只要对这个组件中的 `<input>`:
- value 属性绑定到名为 value 的 prop 上。
- input 事件被触发时，将新的值通过自定义的 input 事件抛出。

## 深入组件

### 11 组件注册

#### 11.1 组件名
组件名建议遵循 W3C 规范中的自定义组件名（字母全小写且必须包含一个连字符），这有助于避免和当前以及未来的 html 元素相冲突。

定义组件名的方式有两种：
- kebab-case（短横线分隔命名），引用这个元素时也必须使用 kebab-case。
- PascalCase（首字母大写命名），引用这个元素时 kebab-case 和 PascalCase 两种命名都可以使用。但直接在 DOM（非字符串的模板）中只有 kebab-case 是有效的。

#### 11.2 注册

vue 中组件有两种注册方式：全局注册和局部注册。

**全局注册**

通过 `Vue.component` 来创建组件，注册之后可以用在任何新创建的 Vue 根实例的模板中。

全局注册的行为必须在根 Vue 实例创建之前发生。

全局注册往往不够理想，比如使用 webpack 这样的构建系统，全局注册意味着即使组件没有被使用到，也会包含在最终的构建结果中。

**局部注册**

通过一个普通的 js 对象来定义组件，然后在其他组件实例的 compoents 选项中定义想要使用的组件即可。

**模块系统**

使用了 babel 和 webpack 的模块系统中，推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。然后需要在局部注册之前导入想使用的组件。

对于一些相对通用的基础组件，会导致很多组件中存在一个包含基础组件的长列表。可以使用 webpack 的 `require.context` 只全局注册只写基础组件。

### 问题
vue 如何判断 data 中 message 的修改，浅层比较？（结合不可变数据）

注册组件之后，new Vue 中为什么还要指定 el，这样如何复用呢：
理解：
- Vue.component 是注册组件；
- html 模板中是使用组件，
- new Vue 中是相分离的业务逻辑数据提供

计算属性与方法 中说为什么需要缓存，举的是一个计算属性依赖于另一个开销大的计算属性的例子，这和渲染直接导致的多次计算有区别吗？

绑定内联样式多重值的作用。