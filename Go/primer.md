## 入门速成
Go 是一种静态类型的编译语言。

相比其他许多语言提供许多方法去解决某个给定的问题，Go 只有一种正确的方法来解决问题，这节省了开发人员的时间，并使大型代码库易于维护。

关于包：
- 文件名与包名没有直接关系。
- 文件夹名与包名没有直接关系。
- 同一个文件夹下的文件只能有一个包名，否则编译报错。

### 1. 入门
Go 由包组成。？？工作区？

必须在源文件中非注释的第一行指明文件属于哪个包。 package main 还表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。在程序开始执行并完成初始化后，第一个调用的函数是 `main.main()`，该函数一旦返回就表示程序已经成功执行并立即退出。

编译包名不是 main 的源文件，编译后将产生一个 `.a` 后缀的文件而不是可执行程序。

导入包时：
- 若包名不是以 `.`或`/`开头，则 Go 会在全局文件进行查找；
- 若包名以 `./` 开头，则 Go 会在相对目录中查找；
- 若包名以 `/` 开头，则会在系统的绝对路径中查找；

可见性规则：
- 标识符以一个大写字母开头（public），那么它就可以被外部包的代码所使用，这称为导出；
- 标识符以小写字母开头（private|protected），则对包外是不可见的，在包内可见且可使用。

在 import 导入包之后，可以声明定义多个变量、常量或类型，这些对象的作用域都是全局的，然后声明一个或多个函数。

可以通过两种方式运行 Go 命令：
- Go 是一种编译语言，所以文件首先需要使用 go build 去进行编译，这会创建一个二进制可执行文件，然后可以再运行。
- go run 命令有助于抽象编译步骤，使用它可直接执行对应的程序。

### 2. 数据类型
**布尔型**
**数字类型**
**字符串类型**

类型转换：`type(expression)`

**派生类型**
数组（`var a [3]int`）是相同数据类型的元素序列，在声明定义中要指定长度，不能进行扩展。

数组的长度在运行时不能进行更改，数组也不提供获取子数组的能力。因此，Go 提供了切片类型（动态数组），切片存储一系列元素，可以随时扩展。切片是数组的抽象，使用数组作为底层结构，包含三个组件：容量，长度和指向底层数组的指针。

### 3. 变量声明
1. 指定类型，没有初始化，为默认值（0，false, ''）。
2. 根据值自行判断变量类型。
3. 省略 var，类型由编译器自动推断。 `:=` 左侧若没有声明新的变量，就产生编译错误。
4. 多变量声明。被称为并行或同事赋值，可以使用 `a, b = b, a`交换两个变量的值，也可用于当一个函数返回多个值的时候。

在推断类型时，若右边包含为指明类型的数值常量，则新变量的类型要取决于常量的精度。

var 语句用于声明一个变量列表，与函数的参数列表一样，类型在最后（有初始值可以省略类型： `var i, j int = 1, 2; var k, m = 2, "str"`或``）。var 语句可以出现在包或函数级别。

函数外的每个语句都必须以关键字开始，因此 `:=` 结构不能在函数外使用。

**常量**
1. 常量的数据类型只可以是布尔、数字和字符串，不能用 := 语法声明。
2. 常量通常用于枚举。
3. 常量还可以用 len(), cap(), unsafe.Sizeof() 函数计算表达式的值。
4. iota 特殊常量，可以认为是一个可以被编译器修改的常量。它在 const 关键字出现时被重置为0，const 中每新增一行常量声明将使 iota 计数一次。


### 4. 运算符
可以通过 `&i` 来获取变量 i 的内存地址。`*`是指针运算符。

`_`实际上是一个只写变量，不能得到它的值，也被用于抛弃值（比如并不需要从一个函数中得到所有的返回值）。

Go 没有三目运算符，所以不支持 `?:` 形式的条件判断。

### 5. 条件语句

switch 中，Go 自动提供了每个 case 后面所需的 break 语句，除非以 fallthrough 语句结束，否则分支会自动终止。

没有条件的 switch 同 switch true 一样。

select 语句类似于 switch 语句，但会随机执行一个可运行的 case。若没有 case 可运行，它将阻塞直到有 case 可运行。

if 和 for 语句中表达式都无需小括号，但大括号是必须的。

if 语句可以在条件表达式前执行一个简单的语句，该语句声明的变量作用域仅在 if 之内（可以再任何对应的 else 块中使用）。

go 中明确不支持三元表达式，官方推荐用 if 代替。

### 6. 循环语句

for 语句中的初始化语句和后置语句都是可选的，若都没有，则可以去掉分号，作为 while 使用。

goto 语句可以将控制转移到被标记的语句。

### 7. 函数
调用函数，可以通过两种方式来传递参数：
- 值传递，调用函数时将实际参数复制一份传递到函数中。 默认情况使用值传递。
- 引用传递，在函数中对参数所进行的修改，将影响到实际参数。

函数使用：
- 当函数的两个或多个已命名形参类型相同时，除最后一个类型以外，其他都可以省略。
- 函数可以返回任意数量的返回值。
- 函数也是值，可以像其他值一样传递。
- go 函数也可以是一个闭包。

**命名返回值**

除了返回值的类型，在定义函数时还可以命名返回值，它们会被视作定义在函数顶部的变量，这些返回值的名称应当具有一定意义，可以作为文档使用。

没有参数的 return 语句会返回已经命名的返回值。这种方式应当仅用在短函数中，在长函数中这会影响代码的可读性。


panic 和 recover 分别用于报告和处理运行时错误或程序自定义的错误条件。

**defer**
关键字 defer 允许推迟到函数返回之前一刻才执行某个语句或函数：
- 一般用于释放某些已分配的资源，或执行函数完成后的收尾工作。
- 多个 defer 行为被注册时，会以逆序执行（压入一个栈中，后进先出）。
- 结合 defer 可以实现代码追踪，trace 和 untrace。
- 推迟调用的函数参数会立即求值。

### 8. 语言变量作用域
go 的作用域和 js 类似，go 中变量可以在三个地方声明：
- 函数内定义的局部变量；
- 函数外定义的全局变量；
- 函数定义中的形参，也作为局部变量来使用。

### 9. 指针
一个指针变量指向了一个值的内存地址，在指针类型前面加上 * 号可以获取指针指向的内容。

一个指针被定义后没有分配任何变量时，值为 nil。

指针变量通常缩写为 ptr。

使用指针的原因？函数会将参数复制一遍的原因吗，而传递指针指向的是同一个栈内存地址？

### 10. 结构体
type 语句设定了结构体的名称，struct 语句定义了一个新的数据类型。

```go
type Vertex struct {
  x int
  y int
}
a := Vertex{1, 2}
b := Vertex{x: 3}
```

对于一个指向结构体的指针 p, 可以通过 (*p).x 来访问其字段。但这样写太繁杂，所以 Go 允许我们使用隐式简介引用，直接写 p.x 就可以。

可以通过直接列出字段的值来新分配一个结构体，使用 `Name: value` 语法可以仅列出部分字段（其他自动取默认值）。

### 11. 切片
切片的语法类似没有长度的数组语法：`[]bool{true, false, true}`，这会创建一个数组，然后构建一个引用了它的切片。 

```go
//来自于数组
primes := [4]int{2,3,4,5}
var s []int = primes[1:4]
//切片文法
q := []int{2,3,4,5}
//make 创建动态数组
a := make([]int, 4)
```

特点：
- 与数组相比切边的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。
- 切片在初始化之前默认为 nil, 长度为 0，此时没有底层数组。
- 可以通过设置上下限（前闭后开）来设置截取切片：`[lower-bound:upper-bound]`。切片下界默认值为 0，上界是该切片的长度。
- 切片并不存储任何数据，它只是描述了底层数组中的一段，也就是说更改切片的元素会修改其底层数组中对应的元素。
- 切片可以包含任何类型，包括其他的切片。

方法：
- len() 可以获取其长度。
- cap() 可以获取其容量，从切片的第一个元素开始，到其底层数组元素末尾的个数。
- append() 添加一个或多个新元素，会返回一个新的切片，包含了原有切片所有元素和新添加的元素；当底层数组太小，不足以容纳所有给定的值时，会分配一个更大的数组，而返回的切片则会指向这个新分配的数组。
- copy() 拷贝切片。
- 与创建动态数组一样，切片也可以用内建函数 make 来创建。make 函数会分配一个元素为零值的数组并返回一个引用了它的切片。第二个参数指定它的长度，第三个参数指定它的容量。




### 12. 范围 range
range 关键字用于
- for 循环中迭代 array、slice、channel 或 map 的元素。
- 在 array、slice 中 ranger 返回索引和对应的值，在 map 中返回 key-value 对。
- 可以将值或下标赋予 _ 来忽略它。

### 13. map
无序的键值对的集合，最重要的一点是通过 key 来快速检索数据。可以向迭代数组和切片那样迭代它，但 map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。

可以使用 for-range 循环遍历 map。

map 的零值为 nil，nil 映射即没有键，也不能添加键。

make 函数会返回给定类型的映射，并将其初始化备用。
```go
type vertex struct {
  x int
}
var m map[string]Vertex

//映射文法与结构体相似，但必须有键名
var ma = map[string]Vertex{
  "key": Vertext{2}
}

//若顶级类型只是一个类型名，则可以再文法的元素中省略它
var maa = map[string]Vertex{
  "key": {3}
}

func main() {
  m = make(map[string]Vertex)
  m["key"] = Vertex{x: 1}
  fmt.Println(ma)
}

//删除元素
delete(m, key)
//双赋值检测某个键是否存在
elem, ok := m[key]  //ok 为 true 或 false, elem 为对应的值或映射的元素类型的零值。
```

### 14. 方法

方法就是一类带特殊的 接受者 参数的函数，接受者 在参数列表中位于 func 关键字和方法名之间（`func (v Vertex) Abs() float64 {}`）。

方法：
- go 中没有类，但可以为结构体定义方法；也可以为非结构体类型声明方法。
- 只能为同一包内定义的类型的接受者声明方法（int 之类的内建类型也不行）
- 可以为指针接受者声明方法（不能是 *int 这样的的指针）。指针接受者的方法可以修改接受者指向的值，因为方法经常需要修改接收者，所以指针接收者是更常用。若使用值接收者，那么方法只会对值的副本进行操作（应该就是函数传参传副本）。

方法和函数：
- 带指针参数的函数必须接受一个指针；而以指针为接收者的方法被调用时，接收者即能为值又能为指针（对于接收者为指针的方法，接收者为值时，go 会将语句 `v.Scale()` 解释为 `(&v).Scale()`）。
- 相反，以值为参数的函数必须接受一个指定类型的值；而以值为接受者的方法被调用时，接收者既能是值也能是指针（对于接收者为值的方法，接收者为指针时，go 会将语句 `p.Abs()` 解释为 `(*p).Abs()`）。需要注意的是，为值时二者都传的是副本。

指针接收者优势：
- 能够修改其接收者指向的值
- 避免每次调用方法时复制值，更加高效。

### 15. 接口
Go 中没有类和继承的概念，但有非常灵活的接口概念，通过它可以实现很多面向对象的特性。

接口也是一种数据类型，它把所有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

按照约定，接口的名字有方法名加 `[e]r` 后缀组成，不合适时也可以以 `able` 结尾或 `I` 开头。

特点：
- 接口类型的变量可以保存任何实现了这些方法的值，而若是方法使用的指针接受者，则变量也只能保存值的指针而不是值本身。
- Go 中接口可以有值，一个接口类型的变量（`var i Namer`）是一个多字（multiword）数据结构，它的值是 nil，本质上是一个指针（不完全相同，指向接口值的指针是非法的）。若是赋予接口变量的值本身是 nil（比如声明了没有初始化），则方法仍然会被 nil 接收者调用，所以可以再方法中添加判断处理。 
- 类型不需要显示声明实现了某个接口，只要实现了一个接口的所有方法就实现了该接口。这从接口的实现中解耦了定义，接口的实现可以出现在任何包中，无需提前准备。
- 接口变量中包含了接收者实例的值和指向对应方发表的指针（官方：在内部，接口指可以看做包含值和具体类型的元祖`(value, type)`，接口值调用时会执行其底层类型的同名方法）。这样可以实现 go 的多态，可以这样理解多态：根据当前的类型选择正确的方法，或者说，同一种类型在不同的实例上似乎表现出不同的行为。
- 空接口（指定了零个方法的接口）可以保存任何类型的值（每个类型至少实现了零个方法），被用来处理未知类型的值。

有时也会以一种稍微不同的方式来使用接口：从某个类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。

fmt 包中定义的 Stringer 是最普遍的接口之一，是一个可以用字符串描述自己的类型（接口，类型？）。fmt 包以及其他很多包都通过此接口来打印值。

io 包指定的 io.Reader 接口，表示从数据流的末尾进行读取，Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩、加密等等。io.Reader 接口有一个 Read 方法可以用数据填充给定的字节切片并返回填充的字节数和错误值。

#### 15.1 类型断言
类型断言提供了访问接口值底层具体值的方式： `t := i.(T)`，断言接口值 i 保存了具体类型 T，并将底层类型为 T 的值赋予变量 t。

若接口变量中并未保存对应类型的值，这样的语句就会触发一个恐慌。因此，与读取映射相同，类型断言可以返回两个值：`t, ok := i.(T)`；若 ok 为 false，则 t 为 T 类型的零值。

**类型选择**

类型选择可以按照顺序从几个类型断言中选择分支，与一般的 switch 语句相似，不同 case 为类型而非值：
```go
switch v := i.(type) {
  case int:
    //问题： 这个 v 咋又是类型又是值？
    fmt.Printf("Twice %v is %v\n", v, v*2)
  case default:
    fmt.Printf("type %T\m", v)
}
```

#### 15.2. 错误处理
Go 通过内置的错误接口提供了非常简单的错误处理机制，定义了一个名为 error 的 interface:
```go
type error interface {
  Error() string
}
```
在编码中可以通过实现 error 接口类型来生成错误信息。

通常函数会返回一个 error 值，调用它的代码应当通过判断这个值是否等于 nil 来进行错误处理（为 nil 表示成功，非 nil 的 error 表示失败）。

### 16. 并发
通过 go 关键字即可开启 goroutine，是由 golang 运行时管理的轻量级线程。

go 语句可以开启一个新的运行期线程（goroutine），以一个不同的、新创建的 goroutine 来执行一个函数，同一个程序中所有 groutine 共享同一个地址空间。

**通道（channel）**
channel 是用来传递数据的一个数据结构，可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。

操作符 `<-` 用于指定通道方向，发送或接受，未指定则为双向通道。
```go
ch := make(chan int)  //声明通道
ch <- v   //把 v 发送到通道 ch
v := <-ch    // 从 ch 接受数据并赋值给 v
```

默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端接受相应的数据。

```go
//如果 sum 函数会执行很久呢？既然是多线程，应该不会等 sum 执行完再往下执行吧，如果是那不就是 await 了。。。
func main() {
  s := []int{7, 2, 8, -9, 4, 0}

  c := make(chan int)
  go sum(s[:len(s)/2], c)
  go sum(s[len(s)/2:], c)
  x, y := <-c, <-c // 从通道 c 中接收

  fmt.Println(x, y, x+y)
}
```

**通道缓冲**
创建通道是可以指定缓冲区大小，带缓冲区的通道允许发送端的数据发送和接受端的数据获取处于异步状态。即发送端发送的数据可以放在缓冲区中，而不是立刻需要接收端去获取数据。

缓冲区大小有限，满了之后，发送端就无法再发送数据了。

发送方情况：
1. 通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。
2. 通道带缓冲，发送方会阻塞直到发送的值被拷贝到缓冲区内。
3. 缓冲区已满，发送方会阻塞直到某个接收方获取到一个值。

**遍历通道与关闭通道**
通过 range 关键字可以遍历读取到的数据，通道接受不到数据后 ok 就为 false，这时通道就可以用 close() 来关闭。

### 杂项
`{` 不能单独放在一行


参考：
- [官方教程中文版](https://tour.go-zh.org/welcome/1)
- [详细教程](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/preface.md)
- [入门速成指南](https://learnku.com/go/t/24715)
- [菜鸟教程]