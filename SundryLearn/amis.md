## amis
### 1. 介绍
amis 是一个低代码前段框架，使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。

建立 amis 到初衷，是对于大部分常用页面，应该使用最简单到方法来实现，甚至不需要学习前端框架和工具。

使用 amis 的好处在于：
1. 不需要懂前端。
2. 不受前端技术更新的影响。
3. 享受 amis 的不断升级。
4. 可以完全使用可视化页面编辑器来制作页面。
5. 提供完整的界面解决方案，只需 JSON 配置就能完成完整功能开发，包括数据获取、表单提交以及验证等功能。
6. 此外，还有其他亮点：内置多种 UI 组件、容器支持无限级嵌套、经历长时间等实战等等。

amis 不适合做：
1. 大量定制 UI（如对于追求个性化视觉效果的toC页面）。
2. 极为复杂或特殊等交互。

### 2. 快速开始
amis 有两种使用方法：
- JS SDK，用于任意页面。
- React，用于 React 项目。

#### 2.1 React 中的使用
**主题样式**

amis 支持三种主题，使用时需要：
1. 在 html 或 js 中引入对应的样式文件。
2. 在渲染器中使用配置主题。

**基本使用**

引入相应的库，引入对应的组件和函数。

amis.render 函数：`(schema, props, env) => JSX.Element`，参数：
- schema 是页面配置；
- props 可以用来传递数据；
- env 是环境变量，可以理解为这个渲染器工具的配置项，需要用户实现部分接口。包含了若干参数如：fetcher、notify、alert、confirm 等等。

### 3. 概念
#### 3.1 配置与组件
amis 的配置就是一段 JSON：
- type 是节点中最重要的字段，它告诉 amis 当前节点需要渲染的是什么组件。
- 其它字段可以认为是组件的属性，组件会根据这些值来渲染页面内容。

容器型的组件可以互相嵌套，从而形成各种树形结构，以实现复杂页面的制作。

#### 3.2 数据域与数据链
**数据域**

数据域是 amis 的一个重要概念，在内容区渲染的模板变量，会在当前组件的数据域中获取对应的值。

组件的 data 属性值是数据域的一种形式，没有显示的配置数据域时，可以假想它的值为一个空对象。

**数据链**
当节点存在于组件树中时，根据数据链来处理各个组件数据域之间的关系。所以当前组件遇到获取变量的场景时：
1. 首先在当前组件的数据域中寻找变量，找到的话就通过数据映射完成渲染，停止寻找过程。
2. 若在当前数据域中没有找到，则向上寻找，在父组件的数据域中，重复步骤 1 和 2.
3. 一直寻找，知道顶级节点（page 节点），结束寻找。

只有少数几个容器组件会创建新的数据域，除了 page，还有 CRUD、Dislog、IFrame 等。不应该直接给容器组件添加 data 属性，而是应该使用 Service 包裹一层。

**初始化配置域**
初始化数据：
1. 最好的方式是为当前组件配置初始化接口 `initApi`。注意：
    - 该接口除了配置字符串，还可以配置复杂的对象结构。
    - 有的组件不支持该接口，一般可以使用 Service 组件来辅助实现。
    - 接口返回字段必须有：status、msg 和 data（必须是 key-value 结构的对象）。
2. 显示配置 data 属性值。

二者同时配置时，数据域会合并他们的数据。

**更新数据域**
部分组件的某些交互或行为会对当前组件的数据域进行更行，如 form、Formula 组件等。他们会将服务器返回的数据与当前数据域进行 merge，然后更新数据域。

#### 3.3 模板
amis 借鉴其他模板引擎，实现了一套模板渲染功能。

**模版字符串**

使用模板字符串，可以使用数据映射语法来获取数据域中变量的值。
模板字符串，可以是普通文本，可以在文本中获取变量，可以渲染 html（显示 html 标签参考数据映射的转义）。

**JS 模板引擎**

amis 支持 JS 模板引擎进行组织输出，内部采用 lodash template 进行实现。

模板字符串和模板引擎不可以交叉使用。

#### 3.4 数据映射
数据映射支持用户通过`${var}`、`$var` 获取当前数据链中某个变量的值，实现灵活的数据配置功能，主要用于模板字符串、自定义 api 请求数据体格式等场景。

默认 amis 在解析模板字符串时，遇到 `$` 字符会尝试去解析该变量并替换它，如果想要输出纯文本，需要在前面加转义字符`\\`。

支持使用`.`号进行链式取值。

在表单提交数据时，可以使用数据映射定制想要的数据格式。

`&`展开所配置的变量，拼接在所对应的数据中。

`$`只提取数组中的指定变量，组成新的数组，赋值给另一个变量。

**过滤器**

过滤器是对数据映射的一种增强，它的作用是对获取数据做一些处理。html 一般是默认过滤器，另外还有 raw、json、toJson、toInt、toFloat、date、now、url_encode、lowerCase、base64Encode、isTrue、isEquals、filter 等等。

amis 支持串联使用过滤器，通过 `|`连接，前一个过滤器的值会作为下一个过滤器的入参。

amis npm 包里面暴露了 registerFilter 方法，通过它可以添加自己的过滤器逻辑。

#### 3.5 表达式
一般来说，属性名类似于 `xxxOn` 的配置项，都可以使用表达式进行配置。表达式语法实际就是 js 代码，注意不要与数据映射混淆。

在 amis 的实现过程中，当正则匹配到某个组件存在 `xxxOn` 语法的属性名时，会尝试：
1. 提取该配置项配置的 js 语句，并以当前组件的数据域作为该段代码的数据作用域，执行代码。
2. 将执行结果赋值给 `xxx` 并添加到组件属性中。
3. 执行渲染，属性名为 `xxx`。

表达式的执行结果预期应该是 boolean 类型值；若不是，则 amis 会根据 js 规则将结果视作 boolean 类型进行判断。

#### 3.5 联动
表达式应用最多的场景，是实现页面的联动效果。类似于：
- 某个条件下隐藏或禁用某个组件，注意表单项隐藏后提交时仍然可能带上该字段。
- 某个条件下请求接口。
- 某个条件下轮询接口或停止轮询。
- ...

**接口联动**

所有初始化接口链接上使用数据映射获取参数的形式时，所引用的变量值发生变化时，会自动重新请求接口。

默认在变量变化时，会自动请求联动的接口。也可以配置请求条件，在当前数据域中某个值符合特定条件才去请求接口。

有时候，变量会频繁变化，则可以使用主动触发的方式来请求接口。如将获取变量值配置到 data 请求体中，再设置其他组件在特定情况下刷新会请求数据到组件。

**组件间联动**
target 属性支持：
1. 通过配置参数来发送数据到目标组件的数据域中，并刷新组件。
2. 配置多个目标，组件 name 用逗号隔开。

组件间联动也可以实现其他基本联动效果，如显隐组件、接口联动等等。

#### 3.5 行为
页面的交互行为，如：弹窗、复制文字到粘贴板、提交等操作，都可以视为页面的*行为*。

在 amis 中，大部分*行为*是跟*行为按钮组件*进行绑定的。一般配置*行为*的步骤为：
1. 添加一个*行为按钮组件*（一般 type 为 `action`）；
2. 配置当前*行为类型*；
3. 根据当前*行为类型*，配置需要的*属性*。

一些特殊组件，比如 Chart 组件中的图标点击行为，可以直接配置 clickAction 来配置行为对象。

#### 3.6 样式
amis 中有大量的功能类 class 可以使用，既可以用在 schema 中，也可以用在自定义组件开发中，掌握来这些 class 几乎可以不用写样式。

### 4. 类型
#### 4.1 schemaNode
schemaNode 是指每一个 amis 配置节点的类型，支持三种类型：
1. 模板
2. schema（配置）
3. schemaArray（配置数组）

**schema**

schema 是组件的 JSON 配置，至少需要一个 `type` 字段，用来标识该 schema 的类型。

body 属性类型是 shcemaNode，即除了模板外，可以嵌套配置其他组件，从而搭建非常复杂的页面应用。

所有的 schema 类型都可以通过配置 `visible`、`hidden`、`visibleOn`或`hiddenOn`来控制组件的显隐。

**schemaArray配置数组**
schemaArray 其实就是支持通过数组配置 schema，从而在某一节点层级下配置多个组件。

#### 4.2 API
API 类型用于配置请求接口的格式，包括请求方式、地址、数据体等等相关配置。

**返回格式**
所有配置在 amis 组件中的接口，最好直接返回固定的个格式：
```json
{
    "status": 0,
    "mas": "",
    data: {
        ...
    }
}
```

**简单配置**
若是只需要配置简单的 ajax 接口，可以使用简单的字符串格式：`[<method>:]<url>`

**复杂配置**
当对接口的交互比较复杂时，可以使用对象类型来进行配置，一些常用属性包括:
- method
- url
- data
- dataType 可以用来指定数据体格式。默认格式是 application/json；当表单项中包含文件类型时，自动使用 multipart/form-data 数据体格式；当设置为 form 时，数据体格式变为 application/x-www-form-urlencoded。
- headers
- sendOn 配置符合某个条件时触发请求。
- cache 设置缓存时间，同样的请求在该时间内不会发起，而是会获取缓存好的请求响应数据。
- responseData  在返回的数据结构不符合预期时，可以配置它来进行修改。
- requestAdaptor 可以在接口请求前，对请求进行一些自定义处理，配置出需要对请求结构。
- adaptor 则是可以对响应进行一些自定义处理
- 若 api 返回的是文件下载，需要加上 `"responseType": "blob"`，同时 header 中还需要配置 content-type 和 content-disposition。
- replaceData 可以用来决定返回的数据是否替换掉当前数据。
- 自动刷新，url 中存在参数时，参数变化都会自动请求接口。想要关闭有两种方式：
  1. 将依赖的数据写在对象形式的 data 中
  2. 对象形式添加 `autoRefresh: false` 属性。

  利用这个功能和 sendOn 接口发送条件，可以做到接口的串行加载。

**接受适配器**
在 JSON 文件中配置时，adaptor 只支持字符串形式


api 和 render 第三个参数 fetch 的区别
fetch 是正对整个应用的统一配置，而 api 只是组件的单独请求方法。


#### 4.3 definitions
definitions 建立当前页面公共的配置项，在其他组件中可以通过 `$ref` 来引用当前配置项中的内容。

definitions 只能在顶级节点中定义。它最大的作用是能够实现对数据结构格式对递归引用你，实现无限层级编辑。

### 5. 高级
#### 5.1 工作原理
amis 的渲染过程是将 json 转成对应的 React 组件。通过 json 的 type 找到对应的 component，然后将其他属性作为 props 传递过去完成渲染。

只根据节点的 type 跟组件一一对应会重名（比如表格中的 text 和表单中的 text 一个负责展示，一个负责输入），因此一个节点要被什么组件渲染，还要携带上下文（context）。

amis 中使用节点的路径（path）来作为上下文信息。

**先匹配 type，再使用 path 和 正则匹配**

1. 是匹配成功就结束匹配了吗，type 相同时，正则也有交集呢？若存在又该如何处理呢？
2. 多使用一个 path 好像比较多余，还要多一层正则比较？不同组件就应该使用不同 type，是因为多人开发、自定义组件时无法确定某个 type 是否已经被使用过了吗？但是这样还是会出现 type 相同，可以使用的正则匹配有交集的情况呀。

#### 5.2

#### 5.3 自定义组件 - React
**React 临时扩展**
amis 的配置最终会转成 React 组件来执行，所以可以直接在 json 配置中写 react 代码来加入一些定制功能。

使用临时扩展一般通过两个属性：
1. children 一个函数，它返回的内容和 React 的 render 相同（jsx），可以在函数中写任意 js 来实现定制需求。函数有两个参数 value，和 onChange，data 可以拿到其他控件的值。
   
   问题：是写的又问题吗？加上 data 不是就有三个参数来吗，且 data 还确实有用。
2. component 该属性可以传入 React Component。若想使用 React Hooks，则应该通过 component 传递，而

**React 注册自定义类型**

临时扩展即简单又灵活，但它是写在配置中的，无法在其他地方复用，也无法在可视化编辑器里编辑。而自定义类型，则满足来这两个需求。

1. 使用 amis 的 `Renderer` 函数可以注册自定义的组件，还能通过 children 属性添加子节点。

   问题：没有看出来和 children 属性又什么关系。
2. 表单项的扩展，可以使用 `FormItem` 注解，而不是 Renderer。因为使用 FormItem 不需要关心样式、验证器、展现方式，只需关心有了值后如何回显，响应用户交互设置新值。
3. 其他不太常用扩展：
   - 自定义验证器 为组件实现额外的验证逻辑。
   - OptionsControl 与 FormItem 相似，但多了 options、source 等配置，且下发了更多的 props。
   - 组件间通信 若组件希望可以被别的组件引用，可以先注册自己，之后其他的组件可以拿到该组件的示例。
   - 其他功能方法 自定义的渲染器 props 回下发一个 env 对象，其中包含了 fetcher、confirm、alert、notify、jumpTo。

#### 5.4 扩展现有组件
**扩展表单验证**

默认的表单验证规则不满足需求，可以通过代码的方式扩展。 amis 的 addRule 方法。

**事件扩展**

amis 默认会将配置项剩余参数都作为 React 的 props 传入对应标签，因此可以添加自己的自定义事件。

问题：没看懂。

**同时支持多种类型编辑**

在表单编辑中，每个 name 一般对应一种类型，若又多种类型，则：
1. 使用另一个名称作为状态。
2. 使用 PipeIn/PipeOut 方法，这种写法复杂度比较高。

**修改组件标签**

有的组件可以设置 wrapperComponent, 如 Form 下默认使用 form 标签，在浏览器中自动回车提交功能，若想去掉，则可以将 wrapperComponent 设置为 div。

### 6 组件
Tpl 输出模板的常用组件。


### 杂项
body 等内容属性的值可以是字符串、html 字符串、对象。

button 实际上是 action 的别名

form 中判断时，没有填写的字段值为 undifiend

form 表单中可以直接访问其他 item 的值，即使是包裹在 service 和 grid 中。因为 form 会将所有的 item 都放进 data 中，所以根据数据链的原理，成功获取到了值？

this.var 方式获取值和 ${var} 获取值的区别

amis 和 amis-editor 是不同步的，可能有些组件在 amis-editor 中不存在

actionType 为 reload 可以刷新 service，实现 service 获取数据的主动触发

样式中的 invisible 可以隐藏元素且不占位置，在某些场景下很有用（比如一个 form item 不需要显示 label，也不需要 label 占位）。visiblity: hidden 应该只是隐藏元素，保留占位才对，这里的设置看起来额外设置了 position: absolute 移除了占位；相对的 display: none 才是不占位；而 class opcacity-0 但设置又没有效果。 
设置的 invisible 检查发现没有勾选，是被覆盖了吗？没有发现其他覆盖内容呀

`columnClass: "w-xxx"` 配置可以固定宽度

json 中添加 className 覆盖表单样式要添加 helper.css