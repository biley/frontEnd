## TypeScript

使用 TS 之前需要先获取：
- 通过 npm 安装
- 安装 Visual Studio 的 TS 插件

.ts 文件经过 `tsc` 编译之后会输出对应的 js 文件。

TS 中的类型注解是一种轻量级的为函数或变量添加约束的方式，TS 提供了静态的代码分析，它可以分析代码结构和提供的类型注解。

有时即使有错误，还是可以编译出对应的 js 文件，但一般在编译时会有错误提示，TS 会警告开发者代码可能不会按照预期执行。在 tsconfig.json 中配置 `noEmitOnError` 可以设置在报错的时候终止 js 文件的生成。

**TS 是静态类型**
按照类型检查的时机来分类，系统类型可以分为：
- 动态类型 在运行时才会进行类型检查，这类语言的**类型错误**往往会导致运行时错误。JS 是一门解释型语言，没有编译阶段，属于动态类型。
-  静态类型 编译阶段就能确定每个变量的类型，这类**类型错误**往往会导致语法错误。TS 在运行前需要先编译为 JS，而在编译阶段就会进行类型检查，属于静态类型。

大部分 JS 代码经过少量修改就能变成 TS 代码，因为 TS 有强大的类型推断，即使不手动声明变量的类型，也能在变量初始化时自动推论出它的类型。

**TS 是弱类型**
按照是否允许隐式转换，系统类型可以分为：
- 弱类型 `1 + '1'` 运行时数字 1 会被隐式转换为字符串 `'1'`。**TS 是完全兼容 JS 的，它不会修改 JS 运行时的特性，所以它们都是弱类型**。
- 相对的，在运行时需要加上强制类型转才 work  的，就属于强类型。

强/弱是相对的，比如有的强类型语言整数和浮点相加时，也能进行隐式类型转换，但大部分情况下是不行的。

这种类型系统体现了 TS 的核心设计理念：在保留 JS 运行时行为的基础上，通过引入静态类型系统来提高代码的可维护性，减少可能出现的 bug。因此 TS 只会在编译时对类型进行静态检查，若有错误，编译时就会报错；而运行时，与普通的 JS 文件一样，不会进行类型检查。

### 1. 类型
### 1.1 基础
在 TS 中，使用 `:` 指定变量的类型。

TS 支持与 JS 几乎相同的数据类型，此外还提供了一些其他类型以方便使用：
1. boolean、number、string，与 JS 中相同，使用对应的构造函数可以生成对应的包装对象。
2. void：表示没有任何类型。一个没有返回值的函数，其返回的类型是 void；而一个 void 类型的变量，只能赋值 undefined 和 null。
3. Null 和 Undefined：默认情况下是除了 never 之外类型的子类型，因此可以赋值给其他几乎所有类型的变量。指定了 --strictNullChecks 标记后，null 和 undefined 只能赋值给 void 和自身类型的变量；在某处可能传入多种类型变量的话，可以使用联合类型。
4. Any：不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，即允许被赋值为任意类型：
   - 在对现有代码进行改的对时候，any 类型十分有用，它允许在编译时可选择地包含或移除类型检查。
   - 当只知道一部分数据的类型时，any 也很有用比如包含了不同类型的数组。

   在 any 类型的变量上，访问任何属性都是允许的。

   变量在声明时未指定类型也未初始化的时候（`let something;`），也会被识别为任意类型。
5. 类型推断：若声明变量时没有指定类型，会根据初始化的值推断变量的类型；若没有初始化的值，则类型被推断为 any。
6. 联合类型：使用 `|` 分隔每个类型，取值可以为多种类型中的一种 `let something: string | number`。
   
   当 TS 不确定一个联合类型的变量到底是哪个类型时，只能访问联合类型中共有的属性或方法（函数参数是联合类型）；联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型。

#### 1.2 数组
1. TS 中，数组有多种定义方式：
   1. 类型 + 方括号 `let arr: number[] = [1, 2]`。
   2. 数组泛型 `let arr: Array<number> = [1, 2]`。
   3. 接口 
      ```ts
      interface NumberArray {
        //只要索引的类型是数字，那么值的类型必须是数字。
        [index: number]: number;
      }
      let arr: NumberArray = [1, 2];
      ```
      虽然接口也可以用来描述数组，但太过复杂。一般用它来表示类数组。
      
      **类数组**
      
      类数组不是数组类型，除了对它的索引进行约束之外，也约束了其他属性。常用的类数组都有自己的接口定义，如 `arguments`，对应的接口为：
      ```ts
      interface IArguments {
        [index: number]: any;
        length: number;
        callee: Function;
      }
      ```
   4. 一个比较常见的做法是用 `any` 表示数组中允许出现任意类型。

#### 1.3 函数
一个函数有输入和输出，要在 TS 中对其进行约束，需要把输入和输出都考虑到。而在 js 中，有两种常见的定义函数的方式：
- 函数声明
- 函数表达式

输入过多或过少的参数，都是不被允许的。

**函数声明**

函数声明的类型定义比较简单 `function sum(s: number, y: number): number {}`。

**函数表达式**

一个对函数表达式的定义，可以写成 `let mySum = function sum(s: number, y: number): number {}`。这样可以通过编译，但事实上，这只对等号右侧的匿名函数进行了类型定义，而等号左边的 `mySum`，则是通过赋值操作进行类型推断得来的。

**推断类型**：在赋值语句的一边指定了类型但是另一边没有类型的话，TS 编译器会自动识别出类型。所以也可以是 mysum 指定了类型，而函数没有指定类型。

若需要手动添加类型，则应该是：`let mySum: (x: number, y: number) => number = function (x: number, y: number): number {}`。

在 TS 的**类型定义**中， `=>`用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。

**使用接口定义函数形状**

也可以使用接口来定义一个函数需要符合的形状：
```ts
interface SumFunc {
  (x: number, y: number): number;
}
let mySum: SumFunc = function(x: number, y: number) {}
```

采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以在之后对函数名赋值时保证参数个数、类型和返回值类型不变。

使用接口定义函数和接口中存在类型为函数的属性的区别在于是否有固定的属性名定义。

**参数**
TS 中参数特点：
- 可选参数 与接口中的可选属性类似，使用 `?` 表示可选的参数。**可选参数必须排在必需参数的后面**。
- 参数默认值 ES6 中，允许给函数的参数添加默认值，TS 会将添加了默认值的参数识别为可选参数，此时**不再必须排在必需参数的后面**。
- 剩余参数 ES6 中，可以使用 `...rest`  的方式获取函数中的剩余参数。事实上，可以用一个数组来定义它 `...items: any[]`。 rest 参数只能是最后一个参数。

**重载**

重载允许一个函数接受不同数量或类型的参数时，做出不同的处理。TS 中可以使用联合类型，再通过判断类型实现重载。

单纯使用联合类型有时不够精确，则可以使用重载定义多个同名函数。TS 会优先从最前面的函数定义开始匹配，所以多个函数若有包含关系，需要优先把精确的定义写在前面。

#### 1.4 类型断言
有时开发人员会比 TS 更了解某个值的详细信息，通常是知道一个实体具有比现有类型更确切的类型。类型断言好比其他语言中的类型转换，但是不进行特殊的数据检查和解构，它没有运行时的影响，只是在编译阶段起作用。

类型断言用来手动指定一个值的类型。类型断言只能够“欺骗” TS 编译器，无法避免运行时错误，所以滥用可能会导致运行时错误。

类型断言有两种形式：
- 尖括号语法：<类型>值。TS 中，尖括号也用于表示一个泛型。
- `as`语法：值 `as` 类型。在 TS 中使用 JSX 时，只有 as 语法断言被允许，尖括号可能被认为是一个组件。

**类型断言用途**

可以认为类型断言是为了解决 TS 添加了类型检查后造成的一些不方便的问题，使用场景：
- 联合类型可以被断言为其中一个类型。eg: 在不确定类型的时候就访问其中一个类型特有的属性或方法。
- 父类可以被断言为子类。
- 任何类型都可以被断言为 any。eg: 临时给 window 添加属性 `(window as any).foo = 1`。
- any 可以被断言为任何类型。第三方库或历史遗留代码等，比如将函数返回值断言成一个精确的类型，方便后续的操作。

**类型断言限制**

在 TS 中，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。

TS 是结构类型系统，类型之间的对比**只会比较他们最终的结构**，而会忽略他们定义时的关系。所以即使两个接口在定义时没有关系，他们的变量也可能像面向对象语言中的子类实例赋值给父类实例一样赋值。

在 TS 中，A 接口包含了 B 接口的所有属性时，则可以说 A 兼容 B（TS 实际的兼容更加复杂）。此时，他们就可以互相进行类型断言了。

因此，可以换一种说法，要使得 A 能够被断言为 B，则只需要 A 兼容 B 或 B 兼容 A 即可。上文类型断言的用途中的场景都可以认为是它的特例。

**双重断言**
使用 `as any as` 可以将任何一个类型断言为任何另一个类型。这可以打破类型断言的限制，如非必要，不要使用它。

**与其它转换对比**
1. vs 类型转换
   类型转换只会影响 TS 编译时的类型，类型断言语句在编译结果中会被删除。所以类型断言不会真的影响到变量的类型，若要进行类型转换，需要直接调用类型转换的方法。
2. vs 类型声明
   类型声明比类型断言更加严格。
   - `a as B`，只需要满足接口 A 兼容接口 B 或接口 B 兼容接口 A 即可。
   - `let a: A = B` ，需要满足 B 兼容 A 才行。
3. vs 泛型
   使用泛型可以更加规范的实现对函数返回值的约束，同时可以去掉代码中的一些 any，是最优的一个解决方案。

#### 1.5 声明文件
使用第三方库时，需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。

如果库的源码本身是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加 declaretion 选项，就可以同时也生成 .d.ts 声明文件。

**声明语句**

有时候第三方库是直接作为一个全局变量或全局函数使用的（比如 JQ），编译器并不清楚它到底是什么，就可以使用声明语句来定义相对的类型（比如 `declare var`）。定义仅用于编译时的检查，在编译结果中会被删除。

声明语句只能定义类型，而不能定义具体的是实现。

**声明文件**

特点：
- 通常所有的声明都–会放到一个单独的文件，也就是声明文件。
- 声明文件必须以 `.d.ts` 为后缀。

一般来说，ts 会解析项目中所有的 `.ts`结尾的文件，也包含 `.d.ts`结尾，所以正常情况下所有 `.ts` 结尾的文件都可以获得声明文件中的类型定义。

`@types`统一管理第三方库的声明文件，可以用它安装对应的**声明模块**。

**书写声明文件**
有的第三方库并没有提供声明文件，就需要自己书写声明文件；或有的时候查看源码时，也需要了解声明文件的实现。

声明文件仅仅用于编译时的检查，其中的内容在编译结果中会被删除。

根据库的使用场景，声明文件的内容和使用会有所区别：
- 全局变量： 通过 script 标签引入第三方库，注入全局变量。
- 直接扩展全局变量：通过 srcipt 标签引入后，改变一个全局变量的结构。
- npm 包： 通过 `import foo form 'foo'` 导入，符合 est 模块规范。
- UMD库： 既可以通过 script 标签引入，也可以通过 `import` 导入。
- 在 npm 包或 UMD 库中扩展全局变量： 引用 npm 包或 UMD 库后，改变一个全局变量的结构。
- 模块插件： 通过 srcipt 或 import 导入后，改变另一个模块的结构。

**全局变量**

全局变量时最简单的一种场景，比如通过 srcipt 标签引入 jquery。

全局变量的声明文件，若是使 `@types` 安装，则不需配置；若是另外下载或自己编写的，则可以直接将声明文件放在当前项目中，建议放到 src 目录下。

全局变量的声明文件主要语法：
- `declare var`、`declare let`、`declare const`
- `declare function` 同样支持重载
- `declare class`
- `declare enum`
- `declare namespace` 早期 ES6 之前，ts 提供的一种模块化方案，使用 module 表示内部模块。ES6 之后，更名为 namespace，不建议再使用。它用来表示全局变量是一个对象，包含很多子属性。
- interface 和 type 可以直接声明一个全局的接口或类型。

namespece 的使用有助于防止命名冲突；多声明相同变量名的语句，可以组合多个声明语句，它们会不冲突的合并起来。

**npm 包**

一般通过 `import foo from 'foo'` 导入一个包，这是符合 es6 模块规范的。

一般来说，npm 包的声明文件可能存在于两个地方：
1. 与 npm 包绑定在一起  判断依据是 package.json 中有 types 字段或有一个 index.d.ts 声明文件。这种模式是最为推荐的。
2. 发布到 @types 中  尝试安装对应的 @types 包就知道是否存在该声明文件。这种模式一般是由于 npm 包的维护者没有提供声明文件，其他人将声明文件发布到 @types 中。

若没有找到对应的声明文件，则需要自己写声明文件。由于是通过 import 导入的模块，声明文件存放的位置也有约束，一般：
1. 在 @type 创建一个对应的 .d.ts 文件，但 node_moduels 目录不稳定，代码也没有保存到仓库中，故一般只用作临时测试。
2. 创建一个 types 目录，专门用来管理自己写的声明文件。这种方式还需要配置 tsconfig.json 中 compilerOptions 的 paths 和 baseUrl 字段。

module 配置可以有多种选项，对应不同的模块导入导出方式，这里主要以常用的 commonjs 为主。

npm 包主要的语法：
- `export` 导出变量
- `export namespace` 导出对象
- `export default` es6 默认导出
- `export =` commonjs 导出模块，很多第三方库是 commonjs 规范的，使用的导入导出方式有所不同。

**export**

与全局变量的声明文件不同，在 npm 包的声明文件中：
1. 使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。
2. 只有在声明文件中使用 exprot 导出，然后再使用 import 导入后，才会引用到这些类型声明。

使用特点：
- 可以混用 declare 和 export，也就是使用 declare 先声明多个变量，最后再用 export 一次性导出。
- 与全局变量的声明文件类似， interface 之前不需要 declare。

**export default**

使用特点：
- 使用 export default 可以导出一个默认值，而使用方引入时不需要再加上 `{}`。
- 只有 function、class 和 interface 可以直接默认导出，其他变量需要先定义。
- 这种默认导出，一般会将导出语句放在整个声明文件的最前面。

#### 1.6 内置对象
JS 中有很多内置对象，它们可以直接在 TS 中当做定义好了的类型。

内置对象指根据标准在全局作用域上存在的对象，这里的标准指 ESCMScript 和其他环境（如 DOM）的标准。

一般使用到的内置对象：
- ECMAScript 内置对象：Boolean、Error、Date、RegExp 等。
- Document、HTMLElement、Event、NodeList 等。

TS 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TS 中的。所以在使用一些常用的方法的时候，TS 实际上已经做了很多类型判断的工作了（比如 MATH)。


### 2. 进阶
#### 2.1 类型别名
类型别名，用来给一个类型起个新名字，使用 `type` 创建类型别名。

类型别名常用于联合类型。

#### 2.2 字符串字面量类型
字符串字面量类型用来约束取值只能是某几个字符串中的一个 `type EventNames =  'click' | 'scroll'`。同样使用 type 进行定义。

#### 2.3 元祖（Tuple）

数组合并了相同类型的对象，而元祖合并了不同类型的对象：
- 元祖（Tuple）：`let x: [string, number]` 允许表示一个已知元素数量和类型的数组，对应位置的元素为对应的类型。
- 当发生越界后，会使用联合类型（包含数组中的所有类型）来替代，进行后续操作。
- 直接对元祖类型的变量进行初始化或赋值的时候，需要提供所有元祖类型中指定的项。

#### 2.4枚举（enum）

枚举`enum Color { Red }`是对 JS 标准数据类型的一个补充，可以为一组**数值**赋予友好的名字：
- 默认情况从 0 开始为元素编号，也可以手动指定成员的值，之后再递增。
- 手动指定数值重复的话会出现覆盖的情况，手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查；手动赋值的值可以是小数或负数，而后续等增步长仍为 1。
- 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射，可以认为定义枚举时：
   ```js
   var Color;
   (function (Color) {
      Color[Color['Red'] = 0] = "Red";
   })(Color || (Color = {}))
   //Color.Red = 0; Color[0] = "Red";
   ```

**常数项和计算所得项**

枚举项有两种类型，常数项和计算所得项。如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错。

枚举成员被当做常数的条件：
- 不具有初始化函数且之前的枚举成员是常数。这种情况下，值为上一个枚举成员的值加 1，第一个初始值为 0。
- 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TS 表达式的子集，可以在编译阶段求值，需要的条件：
  - 数字字面量。
  - 引用之前定义的常数枚举成员。
  - 带括号的常数枚举表达式。
  - +, -, ~ 一元运算符应用于常数枚举表达式。
  - +, -, *, /, %, <<, >>, >>>, &, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。
  
  若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。

所有其他情况(比如 `.` 取属性)的枚举成员都被当做是需要计算得出的值。

**常数枚举**

常数枚举使用 `const enum` 定义，与普通枚举的区别是它会在编译阶段被删除，且不能包含计算成员。

外部枚举使用 `declare enum` 定义。同样，declare 定义的类型只用于编译时的检查，因此外部枚举也会在编译结果中删除。

#### 2.5 类

TS 除了实现 ES6 中类的功能外，还添加了一些新的用法。

面向对象三大特性：封装、继承、多态。多态：有继承而产生了相关的不同的类，对口同一个方法可以有不同的响应。

**public private 和 protected**

TS 中使用的三种访问修饰符：
- public 默认所有方法或属性都是共有的。
- private 私有，不能再声明它的类的外部访问。
- protected 保护，与private 类似，但允许子类方法。

构造函数在修饰符不同时也会影响到类：
- 为 private 时，类不允许被继承或者实例化。
- 为 protected 时，类只允许被继承。
- 修饰符合 `readonly` 还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，是代码更简洁。

**readonly**

readonly 是只读属性关键字，只允许出现在属性声明、索引签名或构造函数中。

有其他访问修饰符时，readonly 需要写在其后面。


**抽象类**

abstract 用于定义抽象类和其中的抽象方法：
- 抽象类不允许被实例化。
- 抽象类中的抽象方法必须被子类实现。

#### 2.6 类与接口
接口可以用于对对象的形状进行描述，另一个用途是对类的一部分行为进行抽象。

一般，一个类只能继承自另一个类，有时不同类之间有一些共有的特性，这是就可以把特性提取成接口，用 `implements` 关键字来实现。一个类可以实现多个接口。

另外，接口与接口之间也可以相互继承。

**接口继承类**

常见的面向对象语言中，接口是不能继承类的，但在 ts 中却可以。

因为在 ts 中，声明一个类时，除了会创建一个类之外，同时也创建了一个对应的类型。所以我们可以使用 `new Point` 来创建实例，也可以用 `: Point` 来表示参数的类型。

因此在作为类型时，我们可以创建可以创建一个与类等价的接口。

所以当接口继承类时，可以认为继承的是类对应的接口，和接口继承接口没有什么本质区别。

需要注意的是，接口相比类少了构造函数和静态属性、方法，所以也可以认为，声明类时创建的类类型只包含其中的实例属性和方法。而接口继承类时，也只会继承它的实例属性和方法。

#### 2.7 泛型（Generics）
泛型是指在定义**函数、接口或类**的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

使用泛型的时候，可以一次定义多个类型参数：`function test<T, U>(tuple: [T, U]): [U, T] {}`

**泛型约束**

在函数内部使用泛型的时候，由于事先不知道他是哪种类型，所以不能随意操作它的属性或方法。这是，就可以对泛型进行约束，只允许传入那些包含特定属性或方法的变量。

泛型约束，一般是让泛型 T extends 定义好的接口，如果参数不满足接口条件，那么在编译阶段会报错。多个类型参数之间也可以互相约束，`T extends U`保证了 U 中不会出现 T 中不存在的字段。

**泛型接口**

可以使用接口的方式来定义一个函数需要符合的形状，所以也可以使用含有泛型的接口来定义函数的形状。泛型参数可以再接口中，也可以提前到接口名上。在接口名上时，使用泛型接口时需要定义泛型的类型。

**泛型类**

与泛型接口类似，泛型也可以用于类的类型定义中。

**默认类型**

在 ts 2.3 以后，可以为泛型中的类型参数指定默认类型。在使用泛型时没有在代码中直接指定类型参数，从实际参数中也无法推测出时，该默认类型就会起作用。

1.  never：表示那些用不存在的值的类型，比如总是会抛出异常的函数等。never 是所有类型的子类型，除了自身，没有其他类型可以赋值给它，即使是 any 也不行。
2.  Object：引用类型。

### 2. 变量声明
var、let、const

const 变量的内部状态是可修改的，幸运的是，TS 允许使用接口将对象的成员设置为只读的。

### 3. 接口
TS 的核心原则之一是对值所具有的结构进行类型检查，又被称为“鸭式辨型法”或“结构性子类型化”。在 TS 中，接口的作用就是为这些类型命名以及为开发的代码或第三方代码定义契约。

在 TS 中，只要在两个类型内部的结构兼容那么这两个类型就是兼容的，这就允许我们在实现接口的时候只要保证包含了接口要求的结构就可以，而不必明确使用 implements 语句。

TS 中接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象外，也常用于对 对象的形状 的描述。

**使用特点**

接口一般大写首字母，有的编程语言会建议接口名称前面加上 `I` 前缀。

定义的变量比接口少一些属性或多一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。传入函数作为参数的变量和参数类型好像可以不一致 ?1

接口是一个类型，不是一个真正的值，它在编译结果中会被删除。

**可选属性**

接口中的属性不全是必需的，可选属性的含义是该属性可以不存在，但也不允许添加未定义的属性。

可选属性会在定义的后面加一个 `?` 符号。

可选属性的好处：
1. 可以对可能存在的属性进行预定义。
2. 可以捕获引用了不存在的属性时的错误，应该是使用了可选属性之后，再使用接口中不存在的属性就会报错。这里即使不适用可选属性也会报错呀?2

**任意属性**
希望一个接口有任意的属性（一个或多个），可以使用 `[propName: string]: any` 来定义。

一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集（可以用联合类型或 any 解决）。

**只读属性**
一些对象属性只能在对象刚刚创建的时候修改其值，可以再属性名前使用 `readonly` 来指定只读属性。

只读的约束在于第一次给对象赋值的时候，而不是第一次给属性赋值的时候。

TS 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以保证数组创建后再也不能被修改。

直接把整个 ReadOnlyArray 赋值到一个普通数组也是不可以的，但可以使用类型断言重写。

readonly 和 const 使用上的区别在于一个是定义变量，一个是定义属性。

参考：
- [TS 入门教程](https://ts.xcatliu.com/introduction/what-is-typescript.html)



### 问题
1. 可选属性：可以捕获引用了不存在的属性时的错误，应该是使用了可选属性之后，再使用接口中不存在的属性就会报错。这里即使不适用可选属性也会报错呀？

2. 传入函数中的变量对象可以和参数的接口类型不符，是因为在编译阶段不会检查到这里？


