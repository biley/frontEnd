### 1. 执行环境(execution context)
##### 1.1 执行环境理解
当程序的执行流进入到一个可执行的代码时，就进入了一个执行环境中。

执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念。可执行代码可以分为:
1. 全局代码：程序载入后的默认环境
2. 函数代码
3. Eval 代码

##### 1.2 执行环境栈
当执行流进入函数时，函数的`执行环境`会被推入一个`环境栈`中，执行完毕之后弹出，将控制权返回给之前的`执行环境`，栈的底部永远是全局执行环境。这样实现的原因是 JS 的解释器是单线程的，即同一时刻只处理一件事情，其他等待执行的上下文或事件就会在环境栈中排队等待。

##### 1.3 执行环境细节
可以将执行环境抽象为一个对象：
```javascript
ExecutionContextObj = {
  scopeChain,   //指向作用域链头结点的指针
  variableObject, //变量对象
  this:{},
}
```
每当一个函数被调用的时候，就会随之创建一个执行环境，在 JS 解释器内部处理执行环境有两个步骤：
1. 调用阶段(函数被调用之后，函数体执行之前)
   - 扫描执行上下文中的形参、函数以及变量，并依次填充变量(活动)对象的属性

      形参 —— 形参：实参 || undefined

      函数 —— 函数名：函数体 (若变量对象中已经存在同名属性，则覆盖)

      变量 —— 变量名：undefined (若变量对象中已经存在同名属性，不会影响到同名属性)
   - 求出 this 的值
   - 创建作用域链
2. 代码执行阶段
   - 给第一步中初始值为 undefined 的变量赋上相应的值(同名属性覆盖)

还可以认为有一个阶段，调用函数前，创建函数时，会创建一个预先包含外部和全局变量(活动)对象的作用域链，保存在内部的[[Scope]]属性中。在调用时再复制其中的对象构建执行环境的作用域链，此后，又一个活动对象被创建并被推入作用域链的前端。

从这里也可以清楚的知道 JS 中的变量、函数**声明提升**的原理。
##### 1.4 变量对象(variable object)
每一个执行环境都有一个与之关联的变量对象(保存了上下文中声明的变量、函数)。

变量对象是规范上的，不可在 JS 环境中访问，是执行环境中定义的，而只有进入到一个环境中，对应的变量对象才会被激活成为活动对象(activation object)(使用 arguments 初始化)。活动对象上的各种属性才能被访问。当在函数内调用其他函数时，当前函数的变量对象依然在激活状态，所以可以通过作用域链访问到其中的变量和函数。

变量对象值包含定义的变量和函数，活动对象还另外包含了 arguments 和 函数形参。

全局对象中的变量对象就是全局对象本身，因此才可以通过全局对象的属性来访问在全局上下文中声明的变量。

##### 1.5. 作用域链
作用域链本质是指向`变量对象(活动对象)`的指针列表。

当代码在一个环境中执行时，会创建`变量对象(活动对象)`的一个`作用域链`，作用域链的作用，是保证对执行环境的有序访问。若改环境是函数，则将其活动对象最为变量对象。作用域链前端的变量对象，来自当前执行环境，下一个变量对象，则来自下一个执行环境。这样，一直延续到全局执行环境。

标识符解析是沿着作用域链一级一级的搜索标识符直到找到为止的过程。

参考：
- 《JavaScript 高级程序设计 第三版》
- https://www.jianshu.com/p/76ed896bbf91
- https://blog.csdn.net/thumd_lee/article/details/53523744
- [js 中的活动对象与变量对象什么区别？](https://www.zhihu.com/question/36393048/answer/71879330)

### 2. 闭包

闭包指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。
1. 若是内部函数被返回，且在其他地方被调用，它仍然可以访问外部函数中的变量。因为内部函数的作用域链中包含了外部函数的作用域。
2. 一般情况下，函数执行完毕,局部活动对象就被销毁，但因为内部函数的引用，外部函数的活动对象依然会留在内存中，虽然其执行环境的作用域链被销毁;直到内部(匿名)函数被销毁后(解除对其引用，设为 null)，外部函数的活动对象才会被销毁。
3. 副作用：闭包是通过作用域链的变量(活动)对象对变量进行访问，而不是单独保存了某些特殊变量,所以闭包只能取到变量的最新的值。在某些情况下，可以创建一个匿名立即执行函数强制让闭包的行为符合预期。
4. 匿名函数的执行环境具有全局性，所以其 this 通常指向 window。
5. this 和 arguments 不存在于作用域链的活动对象中，因此内部函数无法直接访问到外部函数的这两个变量。把外部作用域中的 this 保存在一个闭包能够访问到的变量中(赋值给一个变量，该变量会保存在活动对象中)，可以解决这个问题。

闭包可能会占用更多的内存

### 3. 创建对象

使用Object构造函数和对象字面量可以用来创建单个对象，但创建多个对象可能会产生大量重复代码。

1. 工厂模式 将创建具体对象(使用Object构造函数和对象字面量)的过程抽象为函数。解决了创建多个相似对象的问题，却没有解决对象识别的问题(知道对象的类型)。
2. 构造函数模式 创建自定义构造函数，与工厂模式的区别在于：
   - 没有显示地创建对象;
   - 直接将属性和方法赋给 this 对象;
   - 没有 return 语句;
   - 函数名一般会大写首字母(构造函数与其他函数的唯一区别是调用方式，通过 new 操作符来调用，就可以作为构造函数);
   - 要创建实例，必须使用 new 操作符;

    使用构造函数实际上会经历4步：
    1. 创建一个对象;
    2. 将构造函数的作用域赋给新对象(this 指向该新对象);
    3. 执行构造函数中的代码(为对象添加属性);
    4. 返回新对象;

    使用构造函数创建的实例都有一个 constructor 属性指向构造函数;还可以通过 instanceof 验证构造函数和实例的关系。

    使用构造函数模式的优点在于可以将它的实例标识为一种特定的类型，它的主要问题是:每个方法都要在每个实例上重新创建一遍，因为在ECMAScript 中，函数也是对象。可以通过把函数定义转移到外部来解决，但若有多个这样的函数，那构造函数就没有什么封装性可言了。
3. 原型模式
   每个函数都有一个 prototype 属性，该属性指向一个对象。字面上来讲，prototype 指向通过调用构造函数创建的对象实例的原型对象，而所有的对象实例共享原型对象的属性和方法。
   原型对象特点：
   1. 默认情况下，所有原型对象都自动获得一个 constructor 属性，指向 prototype 所在函数。constructor 之外的其他方法，都是从 Object 继承而来。
   2. 调用构造函数创建的实例，内部包含一个指针[[prototype]] (内部指针)指向原型对象，脚本中无标准的访问方式，chrome、firefox 和 safari 都支持一个属性 `_proto_` 访问。重要的是，这个连接存在于实例和构造函数的原型对象之间。
   3. 动态性：实例与原型之间的连接是一个指针，而不是副本，所以对原型对象的修改能立即在实例上反应出来。但重写整个原型对象相当与把构造函数的 prototype 指向了另外的原型对象，再修改对之前的实例和最初原型都没有影响了。
   4. 虽然内部指针无法在所有的实现中访问到，但可以通过 isPrototypeof() 来确定对象之间是否存在这样的关系。通过 Object.getPrototypeOf() 可以方便取得一个对象的原型。
   5. 当代码读取对象的某个属性的时候，会先搜索对象实例本身，若未找到，则继续搜索内部指针指向的原型对象。这正是多个对象实例共享原型对象保存的属性和方法的基本原理。因此，给对象实例添加同名属性可以屏蔽原型中的属性;也可以使用 delete 操作符删除实例属性，重新访问到原型中的属性。
   6. 对实例和原型的属性检测有多种方法：
      - hasOwnProperty() 可以检测一个属性是否存在于对象实例中。
      - in 操作符有单独使用和在 for-in 循环中使用两种方式：  
        单独使用时，只要通过对象能够访问的属性都能返回 ture,结合 hasOwnProperty 便可以确定属性是否存在，以及存在于实例中还是存在于原型中;  
        for-in 循环返回的是所有通过对象能访问的、可枚举的属性,屏蔽了原型中不可枚举属性([[Enumerable]]标记为false的属性)的实例属性也会在其中，因为所有开发人员定义的属性都是可枚举的。
      - Object.getOwnPropertyNames()可以得到所有的实例属性，而Object.keys() 可以取得对象上所有可枚举的实例属性。

    使用原型模式更简单常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，结果的区别在于 constructor 属性不再指向原构造函数，而是指向 Object 构造函数，instanceof 操作符能返回正确的结果。若 constructor 值很重要，则可以在对象字面量中显示指定 constructor 属性的值，这样的问题是 constructor 的[[Enumerable]]特性被设置为 true;使用Object.defindProperty()定义可以避免这个问题。

    所有原生的引用类型(Object, Array, String等)都是采用原型模式创建的，因此通过原生对象的模型，可以取得所有默认方法的引用，也可以定义新方法(不推荐)。

    原型模式的问题在于：不能为构造函数传递初始化参数，会带来一些不便;更重要的是，原型中存在引用类型时，可能出现意料外的多个实例共享引用类型的情况(基本类型修改时一般会用到 "=",属于对属性的动态添加，会覆盖原型属性;而引用类型则可能使用比如 "push" 直接操作了原型数据)。

4. 组合使用构造函数模式和原型模式

   创建自定义类型最常见的方式，就是组合使用二者，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。

5. 动态原型模式

   组合模式构造函数和原型是独立的，可能会让人困惑。动态原型把所有的信息封装在构造函数中，通过在构造函数中初始化原型，同时兼顾了二者的优点。

   构造函数会多次调用，而原型的初始化一次就够了，可以通过检查某个应该存在的方法是否有效，来决定是否初始化原型：
   ```javascript
   function Person() {
     ...
     //不必检查每个属性和方法，只需要检查其中一个即可
     if(typeof this.sayHello != "function") {
       Person.prototype.sayHello = function() {};
     }
   }
   ```
6. 寄生构造函数模式

   该模式除了使用 new 操作符以及一般会大写构造函数首字母外，与工厂模式没有什么区别。它主要是在一些特殊情况下用来为对象创建构造函数;比如基于一些原生的引用类型,加上一些新的属性、方法定义新的类型。

   该模式仅仅是在构造函数中创建并返回对象，所以该构造函数产生的对象与构造函数的原型对象之间没有关系，也不能依赖 instanceof 来确定类型。

7. 稳妥构造函数模式

   **稳妥对象**指没有公共属性，其方法也不引用 this 的对象，该对象最适合在一些安全的环境(禁止使用 this 和 new )中使用,或防止数据被其他应用程序改动。该模式与寄生构造函数模式的区别在于新创建对象的实例方法不引用 this,也不使用 new 操作符调用构造函数。

   该构造函数中一般会直接用对象的方法返回传入构造函数中的原始参数，而即使有代码再给对象实例添加方法或数据成员，也没有其他属性和方法可以访问到这些参数，这种安全性使得它非常适合在某些安全执行环境下使用。

ajax fetch
js 为什么单线程 块作用域 bind let const var this 原型链 构造 模式
