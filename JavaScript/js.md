### 1. 执行环境(execution context)
##### 1.1 执行环境理解
当程序的执行流进入到一个可执行的代码时，就进入了一个执行环境中。

执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念。可执行代码可以分为:
1. 全局代码：程序载入后的默认环境
2. 函数代码
3. Eval 代码

##### 1.2 执行环境栈
当执行流进入函数时，函数的`执行环境`会被推入一个`环境栈`中，执行完毕之后弹出，将控制权返回给之前的`执行环境`，栈的底部永远是全局执行环境。这样实现的原因是 JS 的解释器是单线程的，即同一时刻只处理一件事情，其他等待执行的上下文或事件就会在环境栈中排队等待。

##### 1.3 执行环境细节
可以将执行环境抽象为一个对象：
```javascript
ExecutionContextObj = {
  scopeChain,   //指向作用域链头结点的指针
  variableObject, //变量对象
  this:{},
}
```
每当一个函数被调用的时候，就会随之创建一个执行环境，在 JS 解释器内部处理执行环境有两个步骤：
1. 调用阶段(函数被调用之后，函数体执行之前)
   - 扫描执行上下文中的形参、函数以及变量，并依次填充变量(活动)对象的属性

      形参 —— 形参：实参 || undefined

      函数 —— 函数名：函数体 (若变量对象中已经存在同名属性，则覆盖)

      变量 —— 变量名：undefined (若变量对象中已经存在同名属性，不会影响到同名属性)
   - 求出 this 的值
   - 创建作用域链
2. 代码执行阶段
   - 给第一步中初始值为 undefined 的变量赋上相应的值(同名属性覆盖)

还可以认为有一个阶段，调用函数前，创建函数时，会创建一个预先包含外部和全局变量(活动)对象的作用域链，保存在内部的 `[[Scope]]` 属性中。在调用时再复制其中的对象构建执行环境的作用域链，此后，又一个活动对象被创建并被推入作用域链的前端。

从这里也可以清楚的知道 JS 中的变量、函数**声明提升**的原理。
##### 1.4 变量对象(variable object)
每一个执行环境都有一个与之关联的变量对象(保存了上下文中声明的变量、函数)。

变量对象是规范上的，不可在 JS 环境中访问，是执行环境中定义的，而只有进入到一个环境中，对应的变量对象才会被激活成为活动对象(activation object)(使用 `arguments` 初始化)。活动对象上的各种属性才能被访问。当在函数内调用其他函数时，当前函数的变量对象依然在激活状态，所以可以通过作用域链访问到其中的变量和函数。

变量对象值包含定义的变量和函数，活动对象还另外包含了 `arguments` 和 函数形参。

全局对象中的变量对象就是全局对象本身，因此才可以通过全局对象的属性来访问在全局上下文中声明的变量。

##### 1.5. 作用域链
作用域链本质是指向`变量对象(活动对象)`的指针列表。

当代码在一个环境中执行时，会创建`变量对象(活动对象)`的一个`作用域链`，作用域链的作用，是保证对执行环境的有序访问。若改环境是函数，则将其活动对象最为变量对象。作用域链前端的变量对象，来自当前执行环境，下一个变量对象，则来自下一个执行环境。这样，一直延续到全局执行环境。

标识符解析是沿着作用域链一级一级的搜索标识符直到找到为止的过程。

参考：
- 《JavaScript 高级程序设计 第三版》
- https://www.jianshu.com/p/76ed896bbf91
- https://blog.csdn.net/thumd_lee/article/details/53523744
- [js 中的活动对象与变量对象什么区别？](https://www.zhihu.com/question/36393048/answer/71879330)

### 2. 闭包

闭包指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。
1. 若是内部函数被返回，且在其他地方被调用，它仍然可以访问外部函数中的变量。因为内部函数的作用域链中包含了外部函数的作用域。
2. 一般情况下，函数执行完毕,局部活动对象就被销毁，但因为内部函数的引用，外部函数的活动对象依然会留在内存中，虽然其执行环境的作用域链被销毁;直到内部(匿名)函数被销毁后(解除对其引用，设为 `null`)，外部函数的活动对象才会被销毁。
3. 副作用：闭包是通过作用域链的变量(活动)对象对变量进行访问，而不是单独保存了某些特殊变量,所以闭包只能取到变量的最新的值。在某些情况下，可以创建一个匿名立即执行函数强制让闭包的行为符合预期。
4. 匿名函数的执行环境具有全局性，所以其 `this` 通常指向 `window。`
5. `this` 和 `arguments` 不存在于作用域链的活动对象中，因此内部函数无法直接访问到外部函数的这两个变量。把外部作用域中的 `this` 保存在一个闭包能够访问到的变量中(赋值给一个变量，该变量会保存在活动对象中)，可以解决这个问题。

闭包可能会占用更多的内存

### 3. 创建对象

使用Object构造函数和对象字面量可以用来创建单个对象，但创建多个对象可能会产生大量重复代码。

1. 工厂模式 将创建具体对象(使用Object构造函数和对象字面量)的过程抽象为函数。解决了创建多个相似对象的问题，却没有解决对象识别的问题(知道对象的类型)。
2. 构造函数模式 创建自定义构造函数，与工厂模式的区别在于：
   - 没有显示地创建对象;
   - 直接将属性和方法赋给 `this` 对象;
   - 没有 `return` 语句;
   - 函数名一般会大写首字母(构造函数与其他函数的唯一区别是调用方式，通过 new 操作符来调用，就可以作为构造函数);
   - 要创建实例，必须使用 new 操作符;

    使用构造函数实际上会经历4步：
    1. 创建一个对象;
    2. 将构造函数的作用域赋给新对象(`this` 指向该新对象);
    3. 执行构造函数中的代码(为对象添加属性);
    4. 返回新对象;

    使用构造函数创建的实例都有一个 `constructor` 属性指向构造函数;还可以通过 `instanceof` 验证构造函数和实例的关系。

    使用构造函数模式的优点在于可以将它的实例标识为一种特定的类型，它的主要问题是:每个方法都要在每个实例上重新创建一遍，因为在ECMAScript 中，函数也是对象。可以通过把函数定义转移到外部来解决，但若有多个这样的函数，那构造函数就没有什么封装性可言了。
3. 原型模式
   每个函数都有一个 `prototype` 属性，该属性指向一个对象。字面上来讲，`prototype` 指向通过调用构造函数创建的对象实例的原型对象，而所有的对象实例共享原型对象的属性和方法。
   原型对象特点：
   1. 默认情况下，所有原型对象都自动获得一个 `constructor` 属性，指向 `prototype` 所在函数。`constructor` 之外的其他方法，都是从 `Object` 继承而来。
   2. 调用构造函数创建的实例，内部包含一个指针[[prototype]] (内部指针)指向原型对象，脚本中无标准的访问方式，chrome、firefox 和 safari 都支持一个属性 `_proto_` 访问。重要的是，这个连接存在于实例和构造函数的原型对象之间。
   3. 动态性：实例与原型之间的连接是一个指针，而不是副本，所以对原型对象的修改能立即在实例上反应出来。但重写整个原型对象相当与把构造函数的 `prototype` 指向了另外的原型对象，再修改对之前的实例和最初原型都没有影响了。
   4. 虽然内部指针无法在所有的实现中访问到，但可以通过 `isPrototypeof()` 来确定对象之间是否存在这样的关系。通过 `Object.getPrototypeOf()` 可以方便取得一个对象的原型。
   5. 当代码读取对象的某个属性的时候，会先搜索对象实例本身，若未找到，则继续搜索内部指针指向的原型对象。这正是多个对象实例共享原型对象保存的属性和方法的基本原理。因此，给对象实例添加同名属性可以屏蔽原型中的属性;也可以使用 `delete` 操作符删除实例属性，重新访问到原型中的属性。
   6. 对实例和原型的属性检测有多种方法：
      - `hasOwnProperty()` 可以检测一个属性是否存在于对象实例中。
      - `in` 操作符有单独使用和在 `for-in` 循环中使用两种方式：  
        单独使用时，只要通过对象能够访问的属性都能返回 `ture` ，结合 `hasOwnProperty` 便可以确定属性是否存在，以及存在于实例中还是存在于原型中;  
        `for-in` 循环返回的是所有通过对象能访问的、可枚举的属性,屏蔽了原型中不可枚举属性(`[[Enumerable]]`标记为 `false` 的属性)的实例属性也会在其中，因为所有开发人员定义的属性都是可枚举的。
      - `Object.getOwnPropertyNames()` 可以得到所有的实例属性，而 `Object.keys()` 可以取得对象上所有可枚举的实例属性。

    使用原型模式更简单常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，结果的区别在于 `constructor` 属性不再指向原构造函数，而是指向 `Object` 构造函数，`instanceof` 操作符能返回正确的结果。若 `constructor` 值很重要，则可以在对象字面量中显示指定 `constructor` 属性的值，这样的问题是 `constructor` 的 `[[Enumerable]]` 特性被设置为 `true`;使用 `Object.defindProperty()` 定义可以避免这个问题。

    所有原生的引用类型( `Object`, `Array`, `String` 等)都是采用原型模式创建的，因此通过原生对象的模型，可以取得所有默认方法的引用，也可以定义新方法(不推荐)。

    原型模式的问题在于：不能为构造函数传递初始化参数，会带来一些不便;更重要的是，原型中存在引用类型时，可能出现意料外的多个实例共享引用类型的情况(基本类型修改时一般会用到 "=",属于对属性的动态添加，会覆盖原型属性;而引用类型则可能使用比如 `push` 直接操作了原型数据)。

4. 组合使用构造函数模式和原型模式

   创建自定义类型最常见的方式，就是组合使用二者，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。

5. 动态原型模式

   组合模式构造函数和原型是独立的，可能会让人困惑。动态原型把所有的信息封装在构造函数中，通过在构造函数中初始化原型，同时兼顾了二者的优点。

   构造函数会多次调用，而原型的初始化一次就够了，可以通过检查某个应该存在的方法是否有效，来决定是否初始化原型：
   ```javascript
   function Person() {
     ...
     //不必检查每个属性和方法，只需要检查其中一个即可
     if(typeof this.sayHello != "function") {
       Person.prototype.sayHello = function() {};
     }
   }
   ```
6. 寄生构造函数模式

   该模式除了使用 `new` 操作符以及一般会大写构造函数首字母外，与工厂模式没有什么区别。它主要是在一些特殊情况下用来为对象创建构造函数;比如基于一些原生的引用类型,加上一些新的属性、方法定义新的类型。

   该模式仅仅是在构造函数中创建并返回对象，所以该构造函数产生的对象与构造函数的原型对象之间没有关系，也不能依赖 `instanceof` 来确定类型。

7. 稳妥构造函数模式

   **稳妥对象**指没有公共属性，其方法也不引用 `this` 的对象，该对象最适合在一些安全的环境(禁止使用 `this` 和 `new` )中使用,或防止数据被其他应用程序改动。该模式与寄生构造函数模式的区别在于新创建对象的实例方法不引用 `this`,也不使用 `new` 操作符调用构造函数。

   该构造函数中一般会直接用对象的方法返回传入构造函数中的原始参数，而即使有代码再给对象实例添加方法或数据成员，也没有其他属性和方法可以访问到这些参数，这种安全性使得它非常适合在某些安全执行环境下使用。

### 4. 继承
许多OO语言都支持两种继承方式：
1. 接口继承 只继承方法签名
2. 实现继承 继承实际的方法

ECMPScript 只支持实现继承，且实现主要依靠原型链来实现。

##### 4.1 原型链
使用原型链实现继承，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，即原型对象等于另一个类型的实例(这里注意 constructor 一般会随着原型的改变而改变)。利用原型链实现继承，属性的查找就会沿着原型链层层向上，原型链的最后指向 Object.prototype。

特点：

1. instanceof 操作符号可以测试实例与原型链中的所有构造函数; isPrototypeOf() 方法也可以原型链中的所有原型。
2. 原型链最主要的问题在于包含引用类型值的原型属性会被所有实例共享，这和创建对象原型模式的主要问题相似; 另一个问题是，在创建子类型实例时，无法在不影响所有对象实例的情况下，给超类构造函数传递参数。

##### 4.2 借用构造函数
借用构造函数(也叫伪造对象或经典继承)，它的思想实现爱子类型构造函数的内部调用超类构造函数。函数只是在特定环境中执行的代码的对象，因此通过 apply() 和 call() 可以在(将来)新创建的对象上执行构造函数。
```JS
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}

function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}
```
这种方式解决了原型链引用类型值共享以及给超类构造函数传参的问题，但无法避免构造函数模式存在的问题 —— 方法都在构造函数中定义，函数无法复用;且在超类型原型中定义的方法和属性，对子类也是不可见的。

##### 4.3 组合继承
组合继承(也叫为经典继承)是JS中最常使用的继承模式，思路是使用原型链实现对原型属性和方法的继承，而通过构造函数实现对实例属性的继承。
```JS
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function () {};

function SubType() {
  SuperType.call(this, 'lili');
  this.age = age;
}
SubType.prototype = new SuperType();
//SubType.prototype.constructor = SubType;
```
##### 4.4 原型式继承
原型式继承并没有严格意义上的构造函数，其想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。
```JS
function object(o) {
  function F() {}
  f.prototype = 0;
  return new F();
}
```
这种对象要求有一个对象作为另一个对象的基础。ECMAScript5 新增 `Object.create(object, options)` 方法规范化了原型式继承，其中参数 options 可选，它与 Object.defineProperties() 的第二个参数格式相同，它指定的属性会覆盖原型对象上的同名属性。

##### 4.5 寄生式继承
寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数。该函数在内部以某种方式来增强对象，最后再像真是它做了所有的工作一样返回对象。
```JS
function createAnother(original) {
  var clone = Object.create(original);
  clone.sayHello = function() {};
  return clone;
}
```
在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式; `Object.create()` 不是必须的，任何能返回新对象的函数都适用于此模式。该模式为对象添加的函数也不能做到函数复用。

##### 4.6 寄生组合式继承

JS中最常用组合继承最大的问题是无论什么情况下，都会调用两次超类构造函数：第一次在创建子类原型的时候，第二次在子类构造函数内部。

寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，需要的只是超类型原型的一个副本。本质上，就是使用寄生式继承来继承超类的原型，然后再将结果指定给子类型的原型：
```JS
//使用 inheritPrototype 来替代组合继承中，子类的原型指向超类实例的部分
function inheritPrototype(subType, superType) {
  var prototype = Object.create(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}
```
该模式只调用一次超类构造函数，因此避免了在子类原型上创建多余的属性，同时原型链保持不变，instanceof 和 isPrototypeOf() 都能正常使用，开发人员普遍认为这是引用类型最理想的继承范式。

### 5. 垃圾收集
JS 具有自动垃圾收集机制，其原理就是找出那些不再继续使用的变量，然后释放其内存，垃圾收集器会按照固定的时间间隔(或代码执行中预定的时间)周期性的执行这一操作。

很多时候，函数执行结束，其中的局部变量就没有存在的必要了，可以回收其内存。但不是所有情况下都能如此简单的得出结论，垃圾收集器必须跟踪变量，对于不再有用的变量打上标记，以备将来回收其内存。用于标识无用变量的策略可能因实现而异同。

1. 标记清除

   标记清除是 JS 中最常用的垃圾收集方式。变量可以标记为“进入环境”和“离开环境”，从逻辑上讲，永远不能释放进入环境的变量所占用的内存。可以使用各种方式来标记变量，比如通过翻转某个特殊的位来记录一个变量合适进入环境，或使用两个列表来分别记录两种标记的变量。

   垃圾收集器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量所引用的变量的标记。而在此之后被加上标记的变量将被视为准备删除 的变量，环境中的变量已经无法访问到这些变量了。

2. 引用计数

   引用计数不太常见，它的含义就是跟踪每个值被引用的次数，每有变量指向该值时，该值的引用次数就加1, 反之减1。当引用次数为0时，说明该值无法再被访问到，可以被内存回收。但在循环引用的情况下，引用次数永远不为0。

垃圾收集是周期性运行的，确定其时间也是一个非常重要的问题。让触发垃圾收集的变量分配、字面量和数组元素的临界值(如256个变量，4096个对象字面量或64KB的字符串)动态修正，是一个比较好的办法：先设置一个默认值，若回收的内存分配量低于15%， 则将临界值加倍; 若回收的内存分配量高于85%，则将临界值重置回默认值。

全局变量和全局对象的属性一般不会被标记清除，要优化内存占用，则需要对它们解除引用(设置为null)。解除引用并不意味着垃圾回收，而是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

基本类型占用固定空间，被保存在栈内存中;而引用类型的值是对象，保存在对内存中。

ajax fetch
js 为什么单线程 块作用域 bind let const var this 原型链 构造 模式
