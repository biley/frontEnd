### 1. 执行环境(execution context)
##### 1.1 执行环境理解
当程序的执行流进入到一个可执行的代码时，就进入了一个执行环境中。

执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念。可执行代码可以分为:
1. 全局代码：程序载入后的默认环境
2. 函数代码
3. Eval 代码

##### 1.2 执行环境栈
当执行流进入函数时，函数的`执行环境`会被推入一个`环境栈`中，执行完毕之后弹出，将控制权返回给之前的`执行环境`，栈的底部永远是全局执行环境。这样实现的原因是 JS 的解释器是单线程的，即同一时刻只处理一件事情，其他等待执行的上下文或事件就会在环境栈中排队等待。

##### 1.3 执行环境细节
可以将执行环境抽象为一个对象：
```javascript
ExecutionContextObj = {
  scopeChain,   //指向作用域链头结点的指针
  variableObject, //变量对象
  this:{},
}
```
每当一个函数被调用的时候，就会随之创建一个执行环境，在 JS 解释器内部处理执行环境有两个步骤：
1. 调用阶段(函数被调用之后，函数体执行之前)
   - 扫描执行上下文中的形参、函数以及变量，并依次填充变量(活动)对象的属性

      形参 —— 形参：实参 || undefined

      函数 —— 函数名：函数体 (若变量对象中已经存在同名属性，则覆盖)

      变量 —— 变量名：undefined (若变量对象中已经存在同名属性，不会影响到同名属性)
   - 求出 this 的值
   - 创建作用域链
2. 代码执行阶段
   - 给第一步中初始值为 undefined 的变量赋上相应的值(同名属性覆盖)

还可以认为有一个阶段，调用函数前，创建函数时，会创建一个预先包含外部和全局变量(活动)对象的作用域链，保存在内部的[[Scope]]属性中。在调用时再复制其中的对象构建执行环境的作用域链，此后，又一个活动对象被创建并被推入作用域链的前端。

从这里也可以清楚的知道 JS 中的变量、函数**声明提升**的原理。
##### 1.4 变量对象(variable object)
每一个执行环境都有一个与之关联的变量对象(保存了上下文中声明的变量、函数以及形参)。

变量对象是规范上的，不可在 JS 环境中访问，是执行环境中定义的，而只有进入到一个环境中，对应的变量对象才会被激活成为活动对象(activation object)(使用 arguments 初始化)。活动对象上的各种属性才能被访问。当在函数内调用其他函数时，当前函数的变量对象依然在激活状态，所以可以通过作用域链访问到其中的变量和函数。

变量对象值包含定义的变量和函数，活动对象还另外包含了 arguments 和 函数形参。

全局对象中的变量对象就是全局对象本身，因此才可以通过全局对象的属性来访问在全局上下文中声明的变量。

##### 1.5. 作用域链
作用域链本质是指向`变量对象(活动对象)`的指针列表。

当代码在一个环境中执行时，会创建`变量对象(活动对象)`的一个`作用域链`，作用域链的作用，是保证对执行环境的有序访问。若改环境是函数，则将其活动对象最为变量对象。作用域链前端的变量对象，来自当前执行环境，下一个变量对象，则来自下一个执行环境。这样，一直延续到全局执行环境。

标识符解析是沿着作用域链一级一级的搜索标识符直到找到为止的过程。

参考：
- 《JavaScript 高级程序设计 第三版》
- https://www.jianshu.com/p/76ed896bbf91
- https://blog.csdn.net/thumd_lee/article/details/53523744
- [js 中的活动对象与变量对象什么区别？](https://www.zhihu.com/question/36393048/answer/71879330)

### 2. 闭包

闭包指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。
1. 若是内部函数被返回，且在其他地方被调用，它仍然可以访问外部函数中的变量。因为内部函数的作用域链中包含了外部函数的作用域。
2. 一般情况下，函数执行完毕,局部活动对象就被销毁，但因为内部函数的引用，外部函数的活动对象依然会留在内存中，虽然其执行环境的作用域链被销毁;直到内部(匿名)函数被销毁后(解除对其引用，设为 null)，外部函数的活动对象才会被销毁。
3. 副作用：闭包是通过作用域链的变量(活动)对象对变量进行访问，而不是单独保存了某些特殊变量,所以闭包只能取到变量的最新的值。在某些情况下，可以创建一个匿名立即执行函数强制让闭包的行为符合预期。
4. 匿名函数的执行环境具有全局性，所以其 this 通常指向 window

闭包可能会占用更多的内存，

ajax fetch
js 为什么单线程 块作用域 bind let const var this 原型链 构造 模式
