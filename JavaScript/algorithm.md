## 好好审题，可以写几个例子出来找下规律，很多题目其实是找到规律之后就比较好做了（这里可以动笔写一些例子）。不过找规律容易出有考虑不到的地方，这个也要注意。

### 1. 二叉树遍历

**递归**

前序遍历，中序遍历和后序遍历的递归方式都类似，只是递归调用的顺序问题罢了

**迭代**

前序遍历和中序遍历的迭代方式很类似，只是一个是在入栈时访问，一个是在出栈时访问。

后序遍历的迭代方式有些区别，依然使用和前序遍历和中序遍历同样的方式的话，需要给节点加一个额外的属性来标识：但节点第二次出现在栈顶时，才能够访问该节点。
后续遍历的另外一个迭代思路是：模仿递归。[二叉树三种深度遍历方法和实现](https://www.cnblogs.com/sinlyfly/p/11196433.html)

**二叉树路径**

获得所有路径可以使用递归，只是递归中要带上一个路径参数。

使用迭代的话同样可以用栈，类似中序遍历，只是节点要在第二次访问的时候才能出栈（添加一个 flag 属性或者一个 preview 遍历）

### 2. 回溯
回朔法的思想： 回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。

**回朔关键点 通过分析发现，回朔法实现的三大技术关键点分别是：**
1. 一条路走到黑
2. 回退一步
3. 另寻他路

**关键点的实现 那么如何才能用代码实现上述三个关键点呢？**
for 循环
递归

**解释如下**

for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍

递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。

因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔

## sundry
1.  计算二进制中1的个数

``` js
/**
* 计算二进制中1的个数
* @param n
* @return
*/
function count1(int n) {
    let res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```

2. 十进制转二进制看余数

3. 用栈模拟递归转化为非递归
